#!/usr/bin/sh

## Copyright (c) 2024-present Alex Tsvetkov
# SPDX-License-Identifier: Apache-2.0 OR GPL-2.0-or-later

##
## The handles of qdiscs consist of two parts, a major number and a minor number.
## It is habitual to name the root qdisc '1:', which is equal to '1:0'.
## The minor number of a qdisc is always 0.
## Classes need to have the same major number as their parent.
##
## Classes residing under a qdisc share their qdisc major number, but each have a separate minor number
## called a 'classid' that has no relation to their parent classes, only to their parent qdisc.
##
## Major number 0 is allowed but it's reserved for internal use.
##
## Moreover even multiple qdiscs with major number 0 may exist:
##
## qdisc mq 0: root
##  Sent 995827135 bytes 1112122 pkt (dropped 0, overlimits 0 requeues 37)
##  backlog 0b 0p requeues 37
## qdisc pfifo_fast 0: parent :1 bands 3 priomap 1 2 2 2 1 2 0 0 1 1 1 1 1 1 1 1
##  Sent 995827135 bytes 1112122 pkt (dropped 0, overlimits 0 requeues 37)
##  backlog 0b 0p requeues 37
##
## class mq :1 root
##  Sent 995827561 bytes 1112123 pkt (dropped 0, overlimits 0 requeues 37)
##  backlog 0b 0p requeues 37
## class mq :2 root
##  Sent 0 bytes 0 pkt (dropped 0, overlimits 0 requeues 0)
##  backlog 0b 0p requeues 0
##
## Some tc constants:
##   #define TC_H_MAJ_MASK      (0xFFFF0000U)
##   #define TC_H_MIN_MASK      (0x0000FFFFU)
##   #define TC_H_MAJ(h)        ((h)&TC_H_MAJ_MASK)
##   #define TC_H_MIN(h)        ((h)&TC_H_MIN_MASK)
##   #define TC_H_MAKE(maj,min) (((maj)&TC_H_MAJ_MASK)|((min)&TC_H_MIN_MASK))
##   #define TC_H_ROOT          (0xFFFFFFFFU)
##   #define TC_H_INGRESS       (0xFFFFFFF1U)
##
## Interface names in Linux allow all characters except: "/", <space>, NULL.
##

# When any command fails, the shell immediately shall exit,
# as if by executing the exit special built-in utility with no arguments.
# Note: this affects `[ ... ] && ...` within functions. Prefer `[ ... ] || ...` instead.
# Note: calling any command/fn with `|| ...` "switches off" this setting.
#       This is why explicit `return $?` are used everywhere.
set -e

# When the shell tries to expand an unset parameter other than the '@' and '*' special parameters,
# it shall write a message to standard error and the expansion shall fail.
set -u

TCTREE_VERSION="0.30.0"

# Subshell `$()` strips _all_ trailing newline characters
TCTREE_NL="$(printf "\nX")"
TCTREE_NL="${TCTREE_NL%"X"}"

TCTREE_DEFAULT_TEMPLATE='{type} {handle} {kind}'\
'[% if sent_bytes > 0 %] {sent_bytes|traffic} {sent_packets} pkt[% endif %]{nl}'\
'[% if raw_options != "" %][[[{raw_options}]|oneline({__indent_length}, ...)]]{nl}[% endif %]'\
'dropped: {dropped} overlimits: {overlimits} requeues: {requeues} backlog: {backlog} qlen: {qlen}{nl}'
TCTREE_DEFAULT_TEMPLATE_QDISC="$TCTREE_DEFAULT_TEMPLATE"
TCTREE_DEFAULT_TEMPLATE_CLASS="$TCTREE_DEFAULT_TEMPLATE"

TCTREE_DEFAULT_HEADER_WATCH="Node                             Est. rate        Sent   Dropped   Overlim"
TCTREE_DEFAULT_TEMPLATE_WATCH=''\
'[[[{type} {handle} {kind}]|maxlen(30)|pad_end(30)|cut_end({__indent_length})]]'\
'[[[[% if diff:sent_packets > 0 %]{rate:sent_bytes|decmul(8,1)|traffic_rate}[% endif %]]|maxlen(11, ..)|pad_start(12)]]'\
'[[[[% if sent_bytes > 0 %]{sent_bytes|traffic}[% endif %]]|maxlen(11, ..)|pad_start(12)]]'\
'[[[[% if diff:dropped > 0 %]+{diff:dropped}/[% endif %]{dropped}]|maxlen(9, ..)|pad_start(10)]]'\
'[[[[% if diff:overlimits > 0 %]+{diff:overlimits}/[% endif %]{overlimits}]|maxlen(9, ..)|pad_start(10)]]'
TCTREE_DEFAULT_TEMPLATE_QDISC_WATCH="$TCTREE_DEFAULT_TEMPLATE_WATCH"
TCTREE_DEFAULT_TEMPLATE_CLASS_WATCH="$TCTREE_DEFAULT_TEMPLATE_WATCH"

ERR_COMMAND_NOT_SUPPORTED=10
ERR_VAR_NOT_EXISTS=11

ERR_NUMBER_INVALID=20
ERR_NUMBER_NOT_INT=21
ERR_NUMBER_INVALID_HEX=22

ERR_SPACESEP_LIST_NOT_EXISTS=40

ERR_PARSE_UNEXPECTED_FORMAT=50
ERR_PARSE_UNCLOSED_PARENTHESIS=51

ERR_INTERFACE_INVALID_NUMBER=60
ERR_INTERFACE_ROOT_QDISC_NOT_SET=61

ERR_NODE_INVALID_HANDLE=70
ERR_NODE_PROPERTY_NOT_EXISTS=71
ERR_NODE_NS_BY_ID_NOT_EXISTS=72

ERR_RESOLVE_PROP_NOT_FOUND=80

ERR_EXPR_PROP_NOT_FOUND=90
ERR_EXPR_EXPLICIT_PROPERTY_NOT_FOUND=91
ERR_EXPR_INSUFFICIENT_DATA=92
ERR_EXPR_PROP_INVALID_FORMAT=93
ERR_EXPR_TRANSFORMER_FAILED=94

g_benchmark=""
g_debug=""
g_trace=""

g_no_target_titles=""

g_custom_template_set=""

g_hide_common_count=0
g_hide_qdiscs_count=0
g_hide_classes_count=0

g_indent_guide_length=3
g_indent_guide_vert="|"
g_indent_guide_vert_chars=""
g_indent_guide_vert_padded=""
g_indent_guide_vert_padded_chars=""
g_indent_guide_branch="+-"
g_indent_guide_branch_chars=""
g_indent_guide_branch_padded=""
g_indent_guide_branch_padded_chars=""
g_indent_guide_branch_sibling="+-"
g_indent_guide_branch_sibling_chars=""
g_indent_guide_branch_sibling_padded=""
g_indent_guide_branch_sibling_padded_chars=""
g_indent_guide_space=" "
g_indent_guide_space_chars=""
g_indent_guide_space_padded=""
g_indent_guide_space_padded_chars=""

g_watch_mode=""
g_watch_interval_ms=1000
g_watch_clear_cmd="clear"

g_snapshots_capacity=2
g_actual_snapshot=1
g_snapshots_filled=""

g_targets=""
g_targets_count=0

g_interfaces_count=0

g_term_columns=""

g_date_supported=""
g_sleep_supported=""
g_tput_supported=""

##!
##!
##!
usage() {
    sg_is_full="${1-0}"
    sg_basename="$(basename "$0")"

    while IFS="" read -r sg_line || [ -n "$sg_line" ]; do
        printf "%s\n" "${sg_line#"        "}"
    done <<EOT
        Usage: $sg_basename [options] [<...targets>]

        Target is an interface and optionally a handle: <interface>[/<handle>].

        If handle is not specified then interface's root egress and ingress qdiscs are used.
        If no target is specified then all network interfaces are discovered and used as targets.

        Watch mode:
          -w, --watch - periodically refresh data.
          -i, --interval <number> - refresh data interval in seconds (default: 1).
              --snapshots <number> - number of data snapshots to be collected (default: 2).
              --watch-clear-cmd <command> - command to clear the terminal (default: clear).

        Other options:
          --no-target-titles - do not display target titles before the data.
          --header-template <template> - generate and display something before data rows.
          --debug - output debug information.
          --benchmark - profile the script and show performance details.
          --trace - output more debug info and show every executed command (set -x).
          --version - display version and exit.
          --help - show this help message.
          --help-full - show extended help including details on templating and filtering.

EOT

    [ "$sg_is_full" = "1" ] || return 0

    while IFS="" read -r sg_line || [ -n "$sg_line" ]; do
        printf "%s\n" "${sg_line#"        "}"
    done <<EOT
        Nodes filtering:
          --hide <condition> - hide any nodes (and their subtrees) that match the condition.
          --hide-qdisc <condition> - hide qdisc nodes (and their subtrees) that match the condition.
          --hide-class <condition> - hide class nodes (and their subtrees) that match the condition.

        Nodes templating:
          --template <template> - generate text of any nodes from this template.
          --template[-<kind>] <template> - override default template with this kind-specific (e.g. --template-htb).
          --template-qdisc <template> - generate text of qdisc nodes from this template.
          --template-qdisc[-<kind>] <template> - override default template with this kind-specific (e.g. --template-qdisc-htb).
          --template-class <template> - generate text of class nodes from this template.
          --template-class[-<kind>] <template> - override default template with this kind-specific (e.g. --template-class-htb).

        Indent guides:
          --indent-guide-length <number> - number of characters for each level (default: 3).
          --indent-guide-vert <string> - (default: \"|\").
          --indent-guide-vert-chars <number> - (default: vert-string length in bytes).
          --indent-guide-branch <string> - (default: \"+-\").
          --indent-guide-branch-chars <number> - (default: branch-string length in bytes).
          --indent-guide-branch-sibling <string> - (default: \"+-\").
          --indent-guide-branch-sibling-chars <number> - (default: branch-sibling-string length in bytes).
          --indent-guide-space <string> - (default: \" \").
          --indent-guide-space-chars <number> - (default: space-string length in bytes).

        ## Templating and filtering

        Interface properties:
          name, root_qdisc_id, fetch_time.

        Node properties:
          type, kind, handle, parent, parent_major, parent_minor, parent_id, raw_options, sent_bytes, sent_packets, dropped, overlimits, requeues, backlog, qlen.

          HTB:
            qdisc: htb_refcnt, htb_r2q, htb_default, htb_direct_packets_stat, htb_ver, htb_direct_qlen.
            class: htb_prio, htb_quantum, htb_rate, htb_overhead, htb_ceil, htb_linklayer, htb_level, htb_burst, htb_burst_mpu, htb_cburst, htb_cburst_mpu, htb_lended, htb_borrowed, htb_giants, htb_tokens, htb_ctokens.

          fq_codel:
            qdisc: fq_codel_limit, fq_codel_flows, fq_codel_quantum, fq_codel_target, fq_codel_interval, fq_codel_memory_limit, fq_codel_drop_batch, fq_codel_ecn, fq_codel_maxpacket, fq_codel_drop_overlimit, fq_codel_new_flow_count, fq_codel_ecn_mark, fq_codel_ce_mark, fq_codel_memory_used, fq_codel_drop_overmemory, fq_codel_new_flows_len, fq_codel_old_flows_len.
            class: deficit, fq_codel_count, fq_codel_lastcount, fq_codel_ldelay, fq_codel_dropping, fq_codel_drop_next.

        Transformers:
          <value>|transformer[|transformer([arg1[,arg2[,<...>]]])]

          Transformer is a function that takes any value, transforms it and returns the new value.
          Multiple transformers are piped and executed from the left to the right.
          Transformer functions may take optional comma-separated arguments enclosed in parentheses.

          Supported transformers (and their aliases):
            length (len)
            maxlength (maxlen)
            repeat (str_repeat)
            trim
            trim_start (trim_left, left_trim)
            trim_end (trim_right, right_trim)
            pad_start (pad_left, left_pad)
            pad_end (pad_right, right_pad)
            cut_start (cut_left, left_cut)
            cut_end (cut_right, right_cut)
            oneline
            mul (decmul, muldec)
            floor
            traffic
            traffic_rate
            traffic_rate_bps

          Examples:
            2|mul(4)  # 16
            120|mul(30)|traffic  # 3.5 KiB
            "Hello"|repeat(3)  # HelloHelloHello
            "Hello"|repeat(3)|maxlen(10)|pad_end(12, !)  # HelloHello!!

        Expression syntax:
          Expressions return some optionally transformed value.
          They are used in conditions and templates.

          <number>[|<...transformers>]
          <string>[|<...transformers>]
          [<func>:]<property>[|<...transformers>]
          [<func>:]parent.<property>[|<...transformers>]
          [<func>:]interface.<property>[|<...transformers>]

          <number> - integer or decimal.
          <string> - quoted string literal.
          <property> - node/parent/interface property.
          <func> - aggregate function to use in watch-mode.

          Supported functions:
            rate
            diff

          Examples:
            sent_bytes|mul(8)  # sent data in bits
            rate:sent_packets  # packets per second (watch mode, estimated)
            diff:sent_packets  # number of new packets from previous update (watch mode)

        Condition syntax:
          Conditions are evaluated and return a boolean value (true/1 or false/0).
          They are used in filters (if evaluates to true then filter is applied) and templates.

          [!]<property>
            check for node property existence/inexistence.
          [!]parent.<property>
            check for parent node property existence/inexistence.
          [!]interface.<property>
            check for interface property existence/inexistence.

          <expr> <operator> <expr>
            supported operators: =, !=, <, <=, >=, >.

          <condition1> [&& <condition2> [&& <...>]]
            multiple conditions: true if and only if all conditions are true

          Examples:
            htb_prio  # true if node contains this property
            !htb_overhead  # true if node doesn't contain this property
            sent_packets > 0
            kind = "fq_codel"
            rate:sent_bytes|mul(8) > 500000  # true if node's rate exceeds 500 kbit/s
            diff:dropped > 0  # true if there were drops from previous update

        Template syntax:
          Templates are used to generate node's text.
          Indent guides are formed independently of node templates.

          Besides plain texts templates support the following 3 constructs:

            Expressions:
              {<expr>}

              They are usually used to output node's properties (raw or transformed).
              
              Special expressions:
                {nl} - new line
                {__indent_length} - length of the node's indent in characters

            Conditions:
              [% if <condition> %]<...>[% endif %]
              [% if <condition> %]<...>[% else %]<...>[% endif %]

              Conditional output. Nested conditions are not supported.

            Blocks:
              [[[<...>]|<...transformers>]]

              Blocks are usually used to apply transformers to a group of expressions.

          Evaluating order: conditions, expressions, blocks.

          Examples:
            {type} {handle}  # qdisc 1:
            {handle} bits sent: {sent_bytes|mul(8)}  # 1: bits sent: 16384

            [% if sent_bytes > 0 %]Total {sent_bytes} bytes sent[% endif %]
            [% if sent_packets > 0 %]Some packets were seen[% else %]No packets yet[% endif %]
            [% if rate:sent_bytes|mul(8) > 10000 %]More than 10 kbit/s right now![% endif %]

            [[[{type} {handle} {rate:sent_bytes|traffic_rate_bps}]|pad_end(30)]]

        Examples:
        
          # All interfaces
          $sg_basename

          # Only specified interfaces
          $sg_basename net0 wwan0

          # Only specified node and its subtree
          $sg_basename net0/1:1

          # Watch mode with refreshing data every 3 seconds
          $sg_basename -w -i 3

          # Hide nodes without traffic
          $sg_basename net0 --hide 'sent_bytes = 0'

          # All net0 nodes except the one with handle 1:10 (including its subtree)
          $sg_basename net0 --hide "handle = '1:10'"

          # This may be seen as alias to \`--hide 'type = "class" && kind = "fq_codel"'\`
          $sg_basename net0 --hide-class 'kind = "fq_codel"'

          # HTB-tree without fq_codel subtrees
          $sg_basename net0 --hide "parent.kind = 'htb' && kind = 'fq_codel'"

          # Do not show interface's ingress qdisc (if it exists)
          $sg_basename net0 --hide-qdisc 'kind = "ingress"'

          # Example of compact output
          $sg_basename net0 --template "{type} {handle} {kind} sent: {sent_bytes|traffic}"

EOT
}

##!
##!
##!
main() {
    g_targets=""

    m_is_dashdash=""

    while [ $# -gt 0 ]; do
        m_arg="$1"
        shift 1

        if [ "$m_is_dashdash" = "1" ]; then
            g_targets="${g_targets}${g_targets:+ }$m_arg"
            continue
        fi

        case "$m_arg" in
            --template-qdisc)
                # shellcheck disable=SC2034 # appears unused
                g_template_qdisc="$1"
                shift 1
                g_custom_template_set="1"
                ;;
            --template-qdisc-*)
                var_set "g_template_qdisc_${m_arg#"--template-qdisc-"}" "$1"
                shift 1
                g_custom_template_set="1"
                ;;
            --template-class)
                # shellcheck disable=SC2034 # appears unused
                g_template_class="$1"
                shift 1
                g_custom_template_set="1"
                ;;
            --template-class-*)
                var_set "g_template_class_${m_arg#"--template-class-"}" "$1"
                shift 1
                g_custom_template_set="1"
                ;;
            --template)
                g_template_common="$1"
                shift 1
                g_custom_template_set="1"
                ;;
            --template-*)
                var_set "g_template_common_${m_arg#"--template-"}" "$1"
                shift 1
                g_custom_template_set="1"
                ;;
            --hide)
                g_hide_common_count=$((g_hide_common_count + 1))
                var_set "g_hide_common${g_hide_common_count}" "$1"
                shift 1
                ;;
            --hide-qdisc)
                g_hide_qdiscs_count=$((g_hide_qdiscs_count + 1))
                var_set "g_hide_qdiscs${g_hide_qdiscs_count}" "$1"
                shift 1
                ;;
            --hide-class)
                g_hide_classes_count=$((g_hide_classes_count + 1))
                var_set "g_hide_classes${g_hide_classes_count}" "$1"
                shift 1
                ;;
            -w | --watch)
                g_watch_mode="1"
                ;;
            -i | --interval)
                m_interval_ms=""
                decimal_mul "m_interval_ms" "$1" 1000 0 || return $?
                g_watch_interval_ms="$m_interval_ms"
                shift 1
                ;;
            --watch-clear-cmd)
                g_watch_clear_cmd="$1"
                shift 1
                ;;
            --snapshots)
                g_snapshots_capacity="$1"
                shift 1
                ;;
            --indent-guide-len | --indent-guides-length)
                g_indent_guide_length="$1"
                shift 1
                ;;
            --indent-guide-vert | --indent-guides-vert)
                g_indent_guide_vert="$1"
                shift 1
                ;;
            --indent-guide-vert-chars | --indent-guides-vert-chars)
                g_indent_guide_vert_chars="$1"
                shift 1
                ;;
            --indent-guide-branch | --indent-guides-branch)
                g_indent_guide_branch="$1"
                shift 1
                ;;
            --indent-guide-branch-chars | --indent-guides-branch-chars)
                g_indent_guide_branch_chars="$1"
                shift 1
                ;;
            --indent-guide-branch-sibling | --indent-guides-branch-sibling)
                g_indent_guide_branch_sibling="$1"
                shift 1
                ;;
            --indent-guide-branch-sibling-chars | --indent-guides-branch-sibling-chars)
                g_indent_guide_branch_sibling_chars="$1"
                shift 1
                ;;
            --indent-guide-space | --indent-guides-space)
                g_indent_guide_space="$1"
                shift 1
                ;;
            --indent-guide-space-chars | --indent-guides-space-chars)
                g_indent_guide_space_chars="$1"
                shift 1
                ;;
            --no-target-title | --no-target-titles)
                g_no_target_titles="1"
                ;;
            --header-template | --headers-template)
                g_header_template="$1"
                shift 1
                ;;
            --benchmark)
                g_benchmark="1"
                ;;
            --debug)
                g_debug="1"
                ;;
            --trace)
                g_trace="1"
                ;;
            -h | --help)
                usage || return $?
                return 0
                ;;
            --help-full)
                usage 1 || return $?
                return 0
                ;;
            --version)
                printf "tctree %s\n" "$TCTREE_VERSION"
                exit 0
                ;;
            --)
                m_is_dashdash="1"
                ;;
            -*)
                exit_err "Unknown option: $m_arg"
                ;;
            *)
                g_targets="${g_targets}${g_targets:+ }$m_arg"
                ;;
        esac
    done

    if [ "$g_trace" = "1" ]; then
        set -x
    fi

    #
    # Check commands for their existence
    #

    fncmd_exists "tc" || exit_err "Command 'tc' is required to be installed"

    g_date_supported="1"
    fncmd_exists "date" || g_date_supported="0"

    g_sleep_supported="1"
    fncmd_exists "sleep" || g_sleep_supported="0"

    g_tput_supported="1"
    fncmd_exists "tput" || g_tput_supported="0"

    #
    # Align/format indent guide strings
    #

    m_indent_spaces=""

    [ "$g_indent_guide_vert_chars" != "" ] || g_indent_guide_vert_chars="${#g_indent_guide_vert}"
    [ "$g_indent_guide_branch_chars" != "" ] || g_indent_guide_branch_chars="${#g_indent_guide_branch}"
    [ "$g_indent_guide_branch_sibling_chars" != "" ] || g_indent_guide_branch_sibling_chars="${#g_indent_guide_branch_sibling}"
    [ "$g_indent_guide_space_chars" != "" ] || g_indent_guide_space_chars="${#g_indent_guide_space}"

    m_pad_times=$(((g_indent_guide_length - g_indent_guide_vert_chars) / g_indent_guide_space_chars))
    str_repeat "m_indent_spaces" "$g_indent_guide_space" "$m_pad_times" || return $?
    g_indent_guide_vert_padded="${g_indent_guide_vert}${m_indent_spaces}"
    g_indent_guide_vert_padded_chars=$((g_indent_guide_vert_chars + g_indent_guide_space_chars * m_pad_times))
    [ "$g_indent_guide_vert_padded_chars" = "$g_indent_guide_length" ] ||
        exit_err "indent guides: vert+space chars number '$g_indent_guide_vert_padded_chars' does not match '$g_indent_guide_length'"

    m_pad_times=$(((g_indent_guide_length - g_indent_guide_branch_chars) / g_indent_guide_space_chars))
    str_repeat "m_indent_spaces" "$g_indent_guide_space" "$m_pad_times" || return $?
    g_indent_guide_branch_padded="${g_indent_guide_branch}${m_indent_spaces}"
    g_indent_guide_branch_padded_chars=$((g_indent_guide_branch_chars + g_indent_guide_space_chars * m_pad_times))
    [ "$g_indent_guide_branch_padded_chars" = "$g_indent_guide_length" ] ||
        exit_err "indent guides: branch+space chars number '$g_indent_guide_branch_padded_chars' does not match '$g_indent_guide_length'"

    m_pad_times=$(((g_indent_guide_length - g_indent_guide_branch_sibling_chars) / g_indent_guide_space_chars))
    str_repeat "m_indent_spaces" "$g_indent_guide_space" "$m_pad_times" || return $?
    g_indent_guide_branch_sibling_padded="${g_indent_guide_branch_sibling}${m_indent_spaces}"
    g_indent_guide_branch_sibling_padded_chars=$((g_indent_guide_branch_sibling_chars + g_indent_guide_space_chars * m_pad_times))
    [ "$g_indent_guide_branch_sibling_padded_chars" = "$g_indent_guide_length" ] ||
        exit_err "indent guides: branch_sibling+space chars number '$g_indent_guide_branch_sibling_padded_chars' does not match '$g_indent_guide_length'"

    m_pad_times=$((g_indent_guide_length / g_indent_guide_space_chars))
    g_indent_guide_space_padded=""
    str_repeat "g_indent_guide_space_padded" "$g_indent_guide_space" "$m_pad_times" || return $?
    g_indent_guide_space_padded_chars=$((g_indent_guide_space_chars * m_pad_times))
    [ "$g_indent_guide_space_padded_chars" = "$g_indent_guide_length" ] ||
        exit_err "indent guides: space chars number '$g_indent_guide_space_padded_chars' does not match '$g_indent_guide_length'"

    #
    # If no target was specified then use all system's interfaces
    #

    if [ "$g_targets" = "" ]; then
        m_net_ifaces="$(ls /sys/class/net)"

        for m_iface in $m_net_ifaces; do
            [ "$m_iface" != "lo" ] || continue
            g_targets="${g_targets}${g_targets:+ }$m_iface"
        done

        if [ "$g_targets" = "" ]; then
            exit_err "No targets were specified and no network interfaces were found"
        fi
    fi

    g_targets_count=0

    for m_target in $g_targets; do
        g_targets_count=$((g_targets_count + 1))

        if [ "${m_target#*"/"}" != "$m_target" ]; then
            m_iface="${m_target%%"/"*}"
            m_node="${m_target#*"/"}"
        else
            m_iface="$m_target"
            m_node=""
        fi

        var_set "g_targets${g_targets_count}_title" "$m_target"
        var_set "g_targets${g_targets_count}_interface" "$m_iface"
        var_set "g_targets${g_targets_count}_node" "$m_node"

        # Add interface to the internal registry and assign its number
        get_interface_number "g_targets${g_targets_count}_interface_number" "$m_iface" || return $?
    done

    if [ "$g_watch_mode" = "1" ]; then
        g_actual_snapshot=0

        while :; do
            g_actual_snapshot=$((g_actual_snapshot + 1))

            if [ "$g_actual_snapshot" -gt "$g_snapshots_capacity" ]; then
                g_actual_snapshot=1
                g_snapshots_filled=1
            fi

            m_watch_iter_start_time=""
            time_ms "m_watch_iter_start_time" || m_watch_iter_start_time=0

            clean_snapshot "$g_actual_snapshot" || return $?

            initialize_snapshot "$g_actual_snapshot" || return $?

            fetch_tc_output "$g_actual_snapshot" || return $?
            process_tc_output "$g_actual_snapshot" || return $?

            m_rendered=""
            render_targets "m_rendered" "$g_actual_snapshot" || return $?

            if [ "$g_watch_clear_cmd" != "" ]; then
                $g_watch_clear_cmd
            fi

            printf "%s" "$m_rendered"

            if [ "$g_sleep_supported" = "1" ]; then
                m_watch_iter_end_time=""
                time_ms "m_watch_iter_end_time" || m_watch_iter_end_time=0

                m_watch_iter_diff_time=0
                [ "$m_watch_iter_end_time" -lt "$m_watch_iter_start_time" ] ||
                    m_watch_iter_diff_time="$((m_watch_iter_end_time - m_watch_iter_start_time))"

                if [ "$m_watch_iter_diff_time" != "0" ] && [ "$m_watch_iter_diff_time" -lt "$g_watch_interval_ms" ]; then
                    m_sleep_secs=""
                    decimal_div "m_sleep_secs" "$((g_watch_interval_ms - m_watch_iter_diff_time))" 1000 3 || return $?

                    sleep "$m_sleep_secs"
                fi
            fi
        done
    else
        initialize_snapshot "$g_actual_snapshot" || return $?

        fetch_tc_output "$g_actual_snapshot" || return $?
        process_tc_output "$g_actual_snapshot" || return $?

        m_rendered=""
        render_targets "m_rendered" "$g_actual_snapshot" || return $?

        printf "%s" "$m_rendered"
    fi
}

##!
##! @param $1 {number} - snapshot number
##!
clean_snapshot() {
    [ "${1-}" != "" ] || exit_err "clean_snapshot: empty argument 1"

    clnsnp_iface_num=0

    while [ "$clnsnp_iface_num" -lt "$g_interfaces_count" ]; do
        clnsnp_iface_num=$((clnsnp_iface_num + 1))

        clean_interface_data "$1" "$clnsnp_iface_num" || return $?
    done
}

##!
##! @param $1 {number} - snapshot number
##!
initialize_snapshot() {
    [ "${1-}" != "" ] || exit_err "initialize_snapshot: empty argument 1"

    ntlsnp_iface_num=0

    while [ "$ntlsnp_iface_num" -lt "$g_interfaces_count" ]; do
        ntlsnp_iface_num=$((ntlsnp_iface_num + 1))

        initialize_interface "$1" "$ntlsnp_iface_num" || return $?
    done
}

##!
##! @param $1 {number} - snapshot number
##!
fetch_tc_output() {
    [ "${1-}" != "" ] || exit_err "fetch_tc_output: empty argument 1"

    ftctpt_iface_num=0

    while [ "$ftctpt_iface_num" -lt "$g_interfaces_count" ]; do
        ftctpt_iface_num=$((ftctpt_iface_num + 1))

        fetch_interface_tc_output "$1" "$ftctpt_iface_num" || return $?
    done
}

##!
##! @param $1 {number} - snapshot number
##!
process_tc_output() {
    [ "${1-}" != "" ] || exit_err "process_tc_output: empty argument 1"

    prctpt_iface_num=0

    while [ "$prctpt_iface_num" -lt "$g_interfaces_count" ]; do
        prctpt_iface_num=$((prctpt_iface_num + 1))

        parse_interface_tc_output "$1" "$prctpt_iface_num" || return $?
        build_interface_tree "$1" "$prctpt_iface_num" || return $?
    done
}

##!
##! @param $1 {identifier} - result out variable name
##! @param $2 {number} - snapshot number
##!
render_targets() {
    [ "${1-}" != "" ] || exit_err "render_targets: empty argument 1"
    [ "${2-}" != "" ] || exit_err "render_targets: empty argument 2"

    if [ "$g_tput_supported" = "1" ]; then
        g_term_columns="$(tput cols)"
    fi

    rdrgts_header=""

    if var_exists "g_header_template"; then
        rdrgts_header="$g_header_template"
    elif [ "$g_watch_mode" = "1" ] && [ "$g_custom_template_set" != "1" ]; then
        rdrgts_header="$TCTREE_DEFAULT_HEADER_WATCH"
    fi

    rdrgts_result=""
    rdrgts_target_num=0

    while [ "$rdrgts_target_num" -lt "$g_targets_count" ]; do
        rdrgts_target_num=$((rdrgts_target_num + 1))

        rdrgts_title=""
        var_set_expanded "rdrgts_title" "g_targets${rdrgts_target_num}_title" || return $?

        rdrgts_iface_num=""
        var_set_expanded "rdrgts_iface_num" "g_targets${rdrgts_target_num}_interface_number" || return $?

        rdrgts_node=""
        var_set_expanded "rdrgts_node" "g_targets${rdrgts_target_num}_node" || return $?

        rdrgts_show_title="1"
        [ "$g_no_target_titles" != "1" ] || rdrgts_show_title=""

        if [ "$rdrgts_show_title" = "1" ]; then
            [ "$rdrgts_target_num" -lt 2 ] || rdrgts_result="${rdrgts_result}$TCTREE_NL"

            if fncmd_exists "format_target_title"; then
                rdrgts_title_formatted=""
                format_target_title "rdrgts_title_formatted" "$rdrgts_title" || return $?
            else
                rdrgts_title_formatted=""
                str_repeat "rdrgts_title_formatted" "=" "${#rdrgts_title}" || return $?
                rdrgts_title_formatted="${rdrgts_title}$TCTREE_NL${rdrgts_title_formatted}$TCTREE_NL"
            fi

            if [ "$rdrgts_title_formatted" != "" ]; then
                rdrgts_result="${rdrgts_result}${rdrgts_title_formatted%"$TCTREE_NL"}$TCTREE_NL"
            fi
        fi

        rdrgts_rendered_node=""
        rdrgts_rendered_status=0
        render_interface_node "rdrgts_rendered_node" "$2" "$rdrgts_iface_num" "$rdrgts_node" ||
            rdrgts_rendered_status=$?
            
        if [ "$rdrgts_rendered_status" != "0" ]; then
            rdrgts_rendered_node="- Cannot render the target -$TCTREE_NL  Error code: $rdrgts_rendered_status"
        else
            str_trim "rdrgts_rendered_node" "$rdrgts_rendered_node" "$TCTREE_NL" || return $?

            if [ "$rdrgts_rendered_node" != "" ]; then
                if [ "$rdrgts_header" != "" ]; then
                    rdrgts_result="${rdrgts_result}${rdrgts_header%"$TCTREE_NL"}$TCTREE_NL"
                fi
            else
                rdrgts_rendered_node="- No data -"
            fi
        fi

        rdrgts_result="${rdrgts_result}${rdrgts_rendered_node}$TCTREE_NL"
    done

    var_set "$1" "$rdrgts_result"
}

#
# FETCH/PARSE/PROCESS
# ==============================================================================

##!
##! @param $1 {number} - snapshot number
##! @param $2 {number} - interface number
##!
clean_interface_data() {
    [ "${1-}" != "" ] || exit_err "clean_interface_data: empty argument 1"
    [ "${2-}" != "" ] || exit_err "clean_interface_data: empty argument 2"

    clnfdt_snapshot_num="$1"
    clnfdt_iface_num="$2"

    clnfdt_iface_name=""
    [ "$g_debug" != "1" ] || get_interface_name "clnfdt_iface_name" "$clnfdt_iface_num"

    [ "$g_debug" != "1" ] || log "Cleaning interface data: $clnfdt_iface_name ($clnfdt_iface_num)"

    clnfdt_iface_namespace=""
    make_interface_namespace "clnfdt_iface_namespace" "$clnfdt_snapshot_num" "$clnfdt_iface_num" || return $?

    [ "$g_debug" != "1" ] || log "Interface namespace: $clnfdt_iface_namespace"

    clnfdt_iface_variables=""

    clnfdt_iface_variables="${clnfdt_iface_variables} name"

    clnfdt_iface_variables="${clnfdt_iface_variables} fetch_time"
    clnfdt_iface_variables="${clnfdt_iface_variables} fetch_failed"

    clnfdt_iface_variables="${clnfdt_iface_variables} qdisc_output"
    clnfdt_iface_variables="${clnfdt_iface_variables} qdiscs_count"
    clnfdt_iface_variables="${clnfdt_iface_variables} qdiscs_ids"
    
    clnfdt_iface_variables="${clnfdt_iface_variables} class_output"
    clnfdt_iface_variables="${clnfdt_iface_variables} classes_count"
    clnfdt_iface_variables="${clnfdt_iface_variables} classes_ids"

    clnfdt_iface_variables="${clnfdt_iface_variables} root_qdisc_id"
    clnfdt_iface_variables="${clnfdt_iface_variables} has_ingress"

    clnfdt_iface_variables="${clnfdt_iface_variables} node_ns_ids"

    for clnfdt_var in $clnfdt_iface_variables; do
        unset "${clnfdt_iface_namespace}${clnfdt_var}" || :
    done

    init_interface_properties "$clnfdt_iface_namespace" || :
}

##!
##! @param $1 {number} - snapshot number
##! @param $2 {number} - interface number
##!
initialize_interface() {
    [ "${1-}" != "" ] || exit_err "initialize_interface: empty argument 1"
    [ "${2-}" != "" ] || exit_err "initialize_interface: empty argument 2"

    ntlnrf_snapshot_num="$1"
    ntlnrf_iface_num="$2"

    ntlnrf_iface_name=""
    [ "$g_debug" != "1" ] || get_interface_name "ntlnrf_iface_name" "$ntlnrf_iface_num" || return $?

    [ "$g_debug" != "1" ] || log "Initializing interface: $ntlnrf_iface_name ($ntlnrf_iface_num)"

    ntlnrf_iface_namespace=""
    make_interface_namespace "ntlnrf_iface_namespace" "$ntlnrf_snapshot_num" "$ntlnrf_iface_num" || return $?

    [ "$g_debug" != "1" ] || log "Interface namespace: $ntlnrf_iface_namespace"

    init_interface_properties "$ntlnrf_iface_namespace" || return $?

    init_node_namespaces_by_id "$ntlnrf_iface_namespace" || return $?
}

##!
##! @param $1 {number} - snapshot number
##! @param $2 {number} - interface number
##!
fetch_interface_tc_output() {
    [ "${1-}" != "" ] || exit_err "fetch_interface_tc_output: empty argument 1"
    [ "${2-}" != "" ] || exit_err "fetch_interface_tc_output: empty argument 2"

    fntctp_snapshot_num="$1"
    fntctp_iface_num="$2"

    [ "$g_benchmark" != "1" ] || tmr_fetch_iface_total="$(print_time_ms)"

    fntctp_iface_name=""
    get_interface_name "fntctp_iface_name" "$fntctp_iface_num" || return $?

    [ "$g_debug" != "1" ] || log "Fetching interface tc-output: $fntctp_iface_name ($fntctp_iface_num)"

    [ "$fntctp_iface_name" != "" ] || 
        exit_err "fetch_interface_tc_output: unexpected empty interface name" # unreachable

    fntctp_iface_namespace=""
    make_interface_namespace "fntctp_iface_namespace" "$fntctp_snapshot_num" "$fntctp_iface_num" || return $?

    [ "$g_debug" != "1" ] || log "Interface namespace: $fntctp_iface_namespace"

    fntctp_is_error=""

    fntctp_time=""
    time_ms "fntctp_time" || fntctp_time=0

    [ "$g_benchmark" != "1" ] || tmr_tc_output="$(print_time_ms)"

    fntctp_qdisc_output="$(tc -s -d qdisc show dev "$fntctp_iface_name")" || fntctp_is_error="1"
    fntctp_class_output="$(tc -s -d class show dev "$fntctp_iface_name")" || fntctp_is_error="1"

    [ "$g_benchmark" != "1" ] || log "Fetched tc output: $(($(print_time_ms) - tmr_tc_output)) ms"

    [ "$g_debug" != "1" ] || log "$fntctp_qdisc_output"
    [ "$g_debug" != "1" ] || log "$fntctp_class_output"

    if [ "$fntctp_is_error" = "1" ]; then
        [ "$g_debug" != "1" ] || log "Fetch failed: clearing outputs"

        fntctp_qdisc_output=""
        fntctp_class_output=""
    fi

    var_set "${fntctp_iface_namespace}qdisc_output" "$fntctp_qdisc_output"
    var_set "${fntctp_iface_namespace}class_output" "$fntctp_class_output"

    var_set "${fntctp_iface_namespace}fetch_failed" "$fntctp_is_error"
    var_set "${fntctp_iface_namespace}fetch_time" "$fntctp_time"

    register_interface_property "$fntctp_iface_namespace" "fetch_time" || return $?

    [ "$g_benchmark" != "1" ] || log "[BLOCK] FETCH INTERFACE: $(($(print_time_ms) - tmr_fetch_iface_total)) ms"
}

##!
##! TODO: Parse with `awk` if available.
##!       Shell is not perfect for text parsing and it takes ~35% of the total execution time.
##!
##! @param $1 {number} - snapshot number
##! @param $2 {number} - interface number
##!
parse_interface_tc_output() {
    [ "${1-}" != "" ] || exit_err "parse_interface_tc_output: empty argument 1"
    [ "${2-}" != "" ] || exit_err "parse_interface_tc_output: empty argument 2"

    prfctp_snapshot_num="$1"
    prfctp_iface_num="$2"

    [ "$g_benchmark" != "1" ] || tmr_parse_iface_total="$(print_time_ms)"

    prfctp_iface_name=""
    get_interface_name "prfctp_iface_name" "$prfctp_iface_num" || return $?

    [ "$g_debug" != "1" ] || log "Parsing interface: $prfctp_iface_name ($prfctp_iface_num)"

    [ "$prfctp_iface_name" != "" ] ||
        exit_err "parse_interface_tc_output: unexpected empty interface name" # unreachable

    prfctp_interface_namespace=""
    make_interface_namespace \
        "prfctp_interface_namespace" \
        "$prfctp_snapshot_num" \
        "$prfctp_iface_num" || return $?

    [ "$g_debug" != "1" ] || log "Interface namespace: $prfctp_interface_namespace"

    #
    # SET INTERFACE NAME PROPERTY
    #

    var_set "${prfctp_interface_namespace}name" "$prfctp_iface_name"
    register_interface_property "$prfctp_interface_namespace" "name" || return $?

    #
    # NODES COMMON
    #

    prfctp_nodes_count=0

    #
    # QDISCS
    #

    [ "$g_benchmark" != "1" ] || tmr_qdisc_parse="$(print_time_ms)"

    prfctp_qdiscs_output=""
    var_set_expanded "prfctp_qdiscs_output" "${prfctp_interface_namespace}qdisc_output" || return $?

    prfctp_qdiscs_count=0
    prfctp_qdiscs_ids=""
    prfctp_has_ingress=""

    if [ "$prfctp_qdiscs_output" != "" ]; then
        prfctp_lines=""

        while IFS="" read -r prfctp_line || [ -n "$prfctp_line" ]; do
            if [ "${prfctp_line#"qdisc"}" != "$prfctp_line" ] || [ "$prfctp_line" = "qdiscend" ]; then
                if [ "$prfctp_lines" != "" ] && [ "${prfctp_lines#"qdisc"}" != "$prfctp_lines" ]; then
                    prfctp_nodes_count=$((prfctp_nodes_count + 1))
                    prfctp_qdiscs_count=$((prfctp_qdiscs_count + 1))

                    [ "$g_debug" != "1" ] || log "Creating qdisc $prfctp_qdiscs_count (node $prfctp_nodes_count)"

                    prfctp_node_namespace=""
                    make_node_namespace \
                        "prfctp_node_namespace" \
                        "$prfctp_snapshot_num" \
                        "$prfctp_iface_num" \
                        "$prfctp_nodes_count" || return $?

                    [ "$g_debug" != "1" ] || log "Qdisc namespace: $prfctp_node_namespace"

                    [ "$g_debug" != "1" ] || log "Initializing properties list"

                    init_node_properties "$prfctp_node_namespace" || return $?

                    parse_common "$prfctp_node_namespace" "qdisc" "$prfctp_lines" || return $?

                    prfctp_node_kind=""
                    var_set_expanded "prfctp_node_kind" "${prfctp_node_namespace}kind" || return $?

                    prfctp_parse_specific="parse_${prfctp_node_kind}"

                    if fncmd_exists "$prfctp_parse_specific"; then
                        $prfctp_parse_specific \
                            "$prfctp_node_namespace" \
                            "qdisc" \
                            "$prfctp_lines" || return $?
                    fi

                    prfctp_lines=""

                    if [ "$prfctp_node_kind" = "ingress" ]; then
                        prfctp_has_ingress="1"
                    fi

                    prfctp_node_handle_major=""
                    var_set_expanded \
                        "prfctp_node_handle_major" \
                        "${prfctp_node_namespace}handle_major" || return $?

                    prfctp_node_id=""

                    # It's allowed for qdiscs to share internal major number '0'.
                    # E.g: qdisc 0: mq <- class :1 mq <- qdisc 0: pfifo_fast
                    # The script uses qdisc's major number as node's id.
                    # With this scheme there would be multiple nodes with the same id "0".
                    # But the script requires node id to be a unique value.
                    # This is why there is a special scheme for nodes with major number '0':
                    # Qdiscs with major number '0' have node id equal to "0" + inttostr((0xffff + 1) + qdisc_num).
                    # Starting those ids with "0" allows detecting such special qdiscs later.
                    if [ "$prfctp_node_handle_major" = "0" ]; then
                        prfctp_node_parent=""
                        var_set_expanded \
                            "prfctp_node_parent" \
                            "${prfctp_node_namespace}parent" || return $?

                        if [ "$prfctp_node_parent" != "" ]; then
                            prfctp_node_id="0$((0xffff + 1 + prfctp_qdiscs_count))"
                        fi
                    fi

                    if [ "$prfctp_node_id" = "" ]; then
                        prfctp_node_id="$prfctp_node_handle_major"
                    fi

                    [ "$g_debug" != "1" ] || log "Parsed and created qdisc ID: $prfctp_node_id"

                    register_node_namespace_by_id \
                        "$prfctp_snapshot_num" \
                        "$prfctp_iface_num" \
                        "$prfctp_node_id" \
                        "$prfctp_node_namespace" || return $?

                    prfctp_qdiscs_ids="${prfctp_qdiscs_ids}${prfctp_qdiscs_ids:+" "}${prfctp_node_id}"
                fi
            fi
            prfctp_lines="${prfctp_lines}${prfctp_line}${TCTREE_NL}"
        done <<EOT
$prfctp_qdiscs_output
qdiscend
EOT
    fi

    [ "$g_benchmark" != "1" ] || log "Parsed qdiscs output: $(($(print_time_ms) - tmr_qdisc_parse)) ms"

    var_set "${prfctp_interface_namespace}qdiscs_count" "$prfctp_qdiscs_count"
    var_set "${prfctp_interface_namespace}qdiscs_ids" "$prfctp_qdiscs_ids"

    [ "$g_debug" != "1" ] || log "Parsed qdiscs count: $prfctp_qdiscs_count"
    [ "$g_debug" != "1" ] || log "Parsed qdiscs IDs: $prfctp_qdiscs_ids"

    var_set "${prfctp_interface_namespace}has_ingress" "$prfctp_has_ingress"

    #
    # CLASSES
    #

    [ "$g_benchmark" != "1" ] || tmr_classes_parse="$(print_time_ms)"

    prfctp_classes_output=""
    var_set_expanded "prfctp_classes_output" "${prfctp_interface_namespace}class_output" || return $?

    prfctp_classes_count=0
    prfctp_classes_ids=""

    if [ "$prfctp_classes_output" != "" ]; then
        prfctp_lines=""

        while IFS="" read -r prfctp_line || [ -n "$prfctp_line" ]; do
            if [ "${prfctp_line#"class"}" != "$prfctp_line" ] || [ "$prfctp_line" = "classend" ]; then
                if [ "$prfctp_lines" != "" ] && [ "${prfctp_lines#"class"}" != "$prfctp_lines" ]; then
                    prfctp_nodes_count=$((prfctp_nodes_count + 1))
                    prfctp_classes_count=$((prfctp_classes_count + 1))

                    [ "$g_debug" != "1" ] || log "Creating class $prfctp_classes_count (node $prfctp_nodes_count)"

                    prfctp_node_namespace=""
                    make_node_namespace \
                        "prfctp_node_namespace" \
                        "$prfctp_snapshot_num" \
                        "$prfctp_iface_num" \
                        "$prfctp_nodes_count" || return $?

                    [ "$g_debug" != "1" ] || log "Class namespace: $prfctp_node_namespace"

                    [ "$g_debug" != "1" ] || log "Initializing properties list"

                    init_node_properties "$prfctp_node_namespace" || return $?

                    parse_common "$prfctp_node_namespace" "class" "$prfctp_lines" || return $?

                    prfctp_node_kind=""
                    var_set_expanded "prfctp_node_kind" "${prfctp_node_namespace}kind" || return $?

                    prfctp_parse_specific="parse_${prfctp_node_kind}"

                    if fncmd_exists "$prfctp_parse_specific"; then
                        $prfctp_parse_specific \
                            "$prfctp_node_namespace" \
                            "class" \
                            "$prfctp_lines" || return $?
                    fi

                    prfctp_lines=""

                    prfctp_node_handle_major=""
                    var_set_expanded \
                        "prfctp_node_handle_major" \
                        "${prfctp_node_namespace}handle_major" || return $?

                    prfctp_node_handle_minor=""
                    var_set_expanded \
                        "prfctp_node_handle_minor" \
                        "${prfctp_node_namespace}handle_minor" || return $?

                    prfctp_node_id="${prfctp_node_handle_major}_${prfctp_node_handle_minor}"

                    [ "$g_debug" != "1" ] || log "Parsed and created class ID: $prfctp_node_id"

                    register_node_namespace_by_id \
                        "$prfctp_snapshot_num" \
                        "$prfctp_iface_num" \
                        "$prfctp_node_id" \
                        "$prfctp_node_namespace" || return $?

                    prfctp_classes_ids="${prfctp_classes_ids}${prfctp_classes_ids:+" "}${prfctp_node_id}"
                fi
            fi
            prfctp_lines="${prfctp_lines}${prfctp_line}${TCTREE_NL}"
        done <<EOT
$prfctp_classes_output
classend
EOT
    fi

    [ "$g_benchmark" != "1" ] || log "Parsed classes output: $(($(print_time_ms) - tmr_classes_parse)) ms"

    var_set "${prfctp_interface_namespace}classes_count" "$prfctp_classes_count"
    var_set "${prfctp_interface_namespace}classes_ids" "$prfctp_classes_ids"

    [ "$g_debug" != "1" ] || log "Parsed classes count: $prfctp_classes_count"
    [ "$g_debug" != "1" ] || log "Parsed classes IDs: $prfctp_classes_ids"

    [ "$g_benchmark" != "1" ] || log "[BLOCK] PARSE INTERFACE: $(($(print_time_ms) - tmr_parse_iface_total)) ms"
}

##!
##! qdisc htb 1: root ...
##! qdisc pfifo a0: parent 1:2 ...
##!
##! class htb 1:1 root ...
##! class htb 1:2 parent 1:1 leaf 2: ...
##!
##! @param $1 {identifier} - node namespace
##! @param $2 {string} - node type
##! @param $3 {string} - node lines
##!
parse_common() {
    [ "${1-}" != "" ] || exit_err "parse_common: empty argument 1"
    [ "${2-}" != "" ] || exit_err "parse_common: empty argument 2"
    [ "${3-}" != "" ] || exit_err "parse_common: empty argument 3"

    prscm_node_namespace="$1"
    prscm_node_type="$2"
    prscm_node_lines="$3"

    [ "$g_debug" != "1" ] || log "Parsing common properties for node namespace '$prscm_node_namespace'"

    prscm_register_properties=""

    prscm_lineno=0

    while IFS="" read -r prscm_line || [ -n "$prscm_line" ]; do
        prscm_lineno=$((prscm_lineno + 1))

        [ "$g_debug" != "1" ] || log "Line num: $prscm_lineno"
        [ "$g_debug" != "1" ] || log "Line content: $prscm_line"

        str_trim_start "prscm_line" "$prscm_line" " " || return $?

        [ "$prscm_line" != "" ] || continue

        # First line contains essential information.
        # Therefore if it cannot be parsed then exit with an error.
        if [ "$prscm_lineno" = "1" ]; then
            prscm_expects=""
            prscm_raw_options=""

            prscm_token_num=0

            for prscm_token in $prscm_line; do
                prscm_token_num=$((prscm_token_num + 1))

                [ "$g_trace" != "1" ] || log "Token num: $prscm_token_num"
                [ "$g_trace" != "1" ] || log "Token value: $prscm_token"

                prscm_property=""
                prscm_property_value=""

                case "$prscm_token_num" in
                    1)
                        [ "$prscm_token" = "$prscm_node_type" ] ||
                            exit_err "Unexpected tc output format: $prscm_line"

                        prscm_property="type"
                        prscm_property_value="$prscm_token"
                        ;;
                    2)
                        prscm_property="kind"
                        prscm_property_value="$prscm_token"
                        ;;
                    3)
                        canonicalize_handle "prscm_token" "$prscm_token" ||
                            exit_err "Unexpected handle: $prscm_token"

                        prscm_property="handle"
                        prscm_property_value="$prscm_token"

                        parse_handle "${prscm_node_namespace}handle_" "$prscm_token" ||
                            exit_err "Unexpected handle: $prscm_token"

                        prscm_register_properties="${prscm_register_properties} handle_major handle_minor"
                        ;;
                    4)
                        if [ "$prscm_token" = "root" ] || [ "$prscm_token" = "dev" ]; then
                            prscm_property="parent"
                            prscm_property_value=""

                            var_set "${prscm_node_namespace}parent_major" ""
                            var_set "${prscm_node_namespace}parent_minor" ""

                            prscm_register_properties="${prscm_register_properties} parent_major parent_minor"
                        elif [ "$prscm_token" = "parent" ]; then
                            prscm_expects="parent"
                        else
                            exit_err "Unexpected tc output format: $prscm_token"
                        fi
                        ;;
                    *)
                        if [ "$prscm_expects" = "parent" ]; then
                            prscm_expects=""

                            canonicalize_handle "prscm_token" "$prscm_token" ||
                                exit_err "Unexpected handle: $prscm_token"

                            prscm_property="parent"
                            prscm_property_value="$prscm_token"

                            parse_handle "${prscm_node_namespace}parent_" "$prscm_token" ||
                                exit_err "Unexpected handle: $prscm_token"

                            prscm_register_properties="${prscm_register_properties} parent_major parent_minor"
                        elif [ "$prscm_token" = "leaf" ]; then
                            prscm_expects="leaf"
                        elif [ "$prscm_expects" = "leaf" ]; then
                            # ignore leaf value
                            prscm_expects=""
                        else
                            prscm_raw_options="${prscm_raw_options}${prscm_raw_options:+" "}${prscm_token}"
                        fi
                        ;;
                esac

                [ "$g_trace" != "1" ] || log "Property name: $prscm_property"
                [ "$g_trace" != "1" ] || log "Property value: $prscm_property_value"

                [ "$prscm_property" != "" ] || continue

                var_set "${prscm_node_namespace}${prscm_property}" "$prscm_property_value"

                prscm_register_properties="${prscm_register_properties} $prscm_property"
            done

            str_trim "prscm_raw_options" "$prscm_raw_options" || return $?

            # Strip ingress's "----------------"
            if [ "${prscm_raw_options#"---"}" != "$prscm_raw_options" ]; then
                str_trim "prscm_raw_options" "$prscm_raw_options" "-" || return $?
            fi

            [ "$g_debug" != "1" ] || log "Raw options: $prscm_raw_options"

            var_set "${prscm_node_namespace}raw_options" "$prscm_raw_options"

            prscm_register_properties="${prscm_register_properties} raw_options"
        else
            prscm_line_first_token=""
            prscm_line_unexpected_format=""
            prscm_line_properties=""
            prscm_expects=""
            prscm_expects_prev=""

            prscm_token_num=0

            for prscm_token in $prscm_line; do
                prscm_token_num=$((prscm_token_num + 1))

                [ "$g_trace" != "1" ] || log "Token num: $prscm_token_num"
                [ "$g_trace" != "1" ] || log "Token value: $prscm_token"

                if [ "$prscm_line_first_token" = "" ]; then
                    prscm_line_first_token="$prscm_token"
                fi

                prscm_property=""
                prscm_property_value=""

                case "$prscm_line_first_token" in
                    Sent | "(dropped")
                        case "$prscm_expects" in
                            "")
                                if [ "$prscm_line_first_token" = "(dropped" ]; then
                                    prscm_expects="statval_dropped"
                                    prscm_line_first_token="Sent"
                                else
                                    prscm_expects="sent_bytes_value"
                                fi
                                ;;
                            "sent_bytes_value")
                                prscm_property="sent_bytes"
                                prscm_property_value="$prscm_token"

                                prscm_expects="sent_bytes_unit"
                                ;;
                            "sent_bytes_unit")
                                [ "$prscm_token" = "bytes" ] || {
                                    prscm_line_unexpected_format="1"
                                    break
                                }
                                prscm_expects="sent_packets_value"
                                ;;
                            "sent_packets_value")
                                prscm_property="sent_packets"
                                prscm_property_value="$prscm_token"

                                prscm_expects="sent_packets_unit"
                                ;;
                            "sent_packets_unit")
                                [ "$prscm_token" = "pkt" ] || {
                                    prscm_line_unexpected_format="1"
                                    break
                                }
                                prscm_expects="stats"
                                ;;
                            "stats")
                                prscm_token="${prscm_token#"("}"
                                case "$prscm_token" in
                                    "dropped" | "overlimits" | "requeues")
                                        prscm_expects="statval_${prscm_token}"
                                        ;;
                                esac
                                ;;
                            statval_*)
                                prscm_stat="$prscm_expects"
                                prscm_stat="${prscm_stat#"statval_"}"

                                case "$prscm_stat" in
                                    "dropped" | "overlimits" | "requeues")
                                        prscm_token="${prscm_token%")"}"
                                        prscm_token="${prscm_token%","}"

                                        prscm_property="$prscm_stat"
                                        prscm_property_value="$prscm_token"
                                        ;;
                                esac

                                # shellcheck disable=SC2034 # appears unused
                                prscm_expects_prev="$prscm_expects"
                                prscm_expects="stats"
                                ;;
                            *)
                                prscm_line_unexpected_format="1"
                                break
                                ;;
                        esac
                        ;;
                    backlog)
                        case "$prscm_expects" in
                            "")
                                prscm_expects="backlog_value"
                                ;;
                            "backlog_value")
                                prscm_property="backlog"
                                prscm_property_value="${prscm_token%"b"}"

                                prscm_expects="qlen_value"
                                ;;
                            "qlen_value")
                                prscm_property="qlen"
                                prscm_property_value="${prscm_token%"p"}"

                                prscm_expects="requeues_literal"
                                ;;
                            "requeues_literal")
                                [ "$prscm_token" = "requeues" ] || {
                                    prscm_line_unexpected_format="1"
                                    break
                                }
                                prscm_expects="requeues_value"
                                ;;
                            "requeues_value")
                                prscm_property="requeues"
                                prscm_property_value="$prscm_token"

                                prscm_expects="end"
                                ;;
                            "end")
                                # Unreachable
                                break
                                ;;
                            *)
                                prscm_line_unexpected_format="1"
                                break
                                ;;
                        esac
                        ;;
                    *)
                        # Unknown line's first token. Break parsing current line and go to the next one.
                        break
                        ;;
                esac

                [ "$g_trace" != "1" ] || log "Property name: $prscm_property"
                [ "$g_trace" != "1" ] || log "Property value: $prscm_property_value"

                [ "$prscm_property" != "" ] || continue

                var_set "${prscm_node_namespace}${prscm_property}" "$prscm_property_value"

                prscm_line_properties="${prscm_line_properties} ${prscm_property} "

                [ "$g_trace" != "1" ] || log "Line properties: $prscm_line_properties"
            done

            # Add properties to the list only when line is known and has expected format
            if [ "$prscm_line_unexpected_format" = "1" ]; then
                [ "$g_debug" != "1" ] || log "Line has an unexpected format"
                continue
            fi

            [ "$g_debug" != "1" ] || log "Line properties (final): $prscm_line_properties"

            if [ "$prscm_line_properties" != "" ]; then
                prscm_register_properties="${prscm_register_properties} ${prscm_line_properties}"
            fi
        fi
    done <<EOT
$prscm_node_lines
EOT

    [ "$g_debug" != "1" ] || log "Properties to register: $prscm_register_properties"

    if [ "$prscm_register_properties" != "" ]; then
        register_node_property "$prscm_node_namespace" "$prscm_register_properties" || return $?
    fi
}

##!
##! @param $1 {identifier} - node namespace
##! @param $2 {string} - node type
##! @param $3 {string} - node lines
##!
parse_htb() {
    [ "${1-}" != "" ] || exit_err "parse_htb: empty argument 1"
    [ "${2-}" != "" ] || exit_err "parse_htb: empty argument 2"
    [ "${3-}" != "" ] || exit_err "parse_htb: empty argument 3"

    case "$2" in
        qdisc)
            parse_htb_qdisc "$1" "$3" || return $?
            ;;
        class)
            parse_htb_class "$1" "$3" || return $?
            ;;
        *)
            exit_err "parse_htb: unknown node type: $2"
            ;;
    esac
}

##!
##! qdisc htb 1: root refcnt 2 r2q 10 default 0x160 direct_packets_stat 0 ver 3.17 direct_qlen 50
##!  Sent 37749499 bytes 29485 pkt (dropped 0, overlimits 257 requeues 0)
##!  backlog 0b 0p requeues 0
##!
##! @param $1 {identifier} - node namespace
##! @param $2 {string} - node lines
##!
parse_htb_qdisc() {
    [ "${1-}" != "" ] || exit_err "parse_htb_qdisc: empty argument 1"
    [ "${2-}" != "" ] || exit_err "parse_htb_qdisc: empty argument 2"

    prhtbqd_node_namespace="$1"
    prhtbqd_node_lines="$2"

    [ "$g_debug" != "1" ] || log "Parsing htb qdisc properties for node namespace '$prhtbqd_node_namespace'"

    prhtbqd_register_properties=""

    prhtbqd_lineno=0

    while IFS="" read -r prhtbqd_line || [ -n "$prhtbqd_line" ]; do
        prhtbqd_lineno=$((prhtbqd_lineno + 1))

        [ "$g_debug" != "1" ] || log "Line num: $prhtbqd_lineno"
        [ "$g_debug" != "1" ] || log "Line content: $prhtbqd_line"

        str_trim_start "prhtbqd_line" "$prhtbqd_line" " " || return $?

        [ "$prhtbqd_line" != "" ] || continue

        prhtbqd_line_first_token=""
        prhtbqd_line_unexpected_format=""
        prhtbqd_line_properties=""
        prhtbqd_expects=""
        prhtbqd_expects_prev=""

        prhtbqd_token_num=0

        for prhtbqd_token in $prhtbqd_line; do
            prhtbqd_token_num=$((prhtbqd_token_num + 1))

            [ "$g_trace" != "1" ] || log "Token num: $prhtbqd_token_num"
            [ "$g_trace" != "1" ] || log "Token value: $prhtbqd_token"

            if [ "$prhtbqd_line_first_token" = "" ]; then
                prhtbqd_line_first_token="$prhtbqd_token"
            fi

            prhtbqd_property=""
            prhtbqd_property_value=""

            case "$prhtbqd_line_first_token" in
                qdisc)
                    case "$prhtbqd_expects" in
                        "")
                            prhtbqd_expects="htb_literal"
                            ;;
                        "htb_literal")
                            prhtbqd_expects="options"
                            ;;
                        "options")
                            case "$prhtbqd_token" in
                                "refcnt" | "r2q" | "default" | "direct_packets_stat" | "ver" | "direct_qlen")
                                    prhtbqd_expects="optval_${prhtbqd_token}"
                                    ;;
                            esac
                            ;;
                        optval_*)
                            prhtbqd_option="$prhtbqd_expects"
                            prhtbqd_option="${prhtbqd_option#"optval_"}"

                            case "$prhtbqd_option" in
                                "refcnt" | "r2q" | "default" | "direct_packets_stat" | "ver" | "direct_qlen")
                                    prhtbqd_property="htb_${prhtbqd_option}"
                                    prhtbqd_property_value="$prhtbqd_token"
                                    ;;
                            esac

                            # shellcheck disable=SC2034 # appears unused
                            prhtbqd_expects_prev="$prhtbqd_expects"
                            prhtbqd_expects="options"
                            ;;
                        *)
                            prhtbqd_line_unexpected_format="1"
                            break
                            ;;
                    esac
                    ;;
                *)
                    # Unknown line's first token. Break parsing current line and go to the next one.
                    break
                    ;;
            esac

            [ "$g_trace" != "1" ] || log "Property name: $prhtbqd_property"
            [ "$g_trace" != "1" ] || log "Property value: $prhtbqd_property_value"

            [ "$prhtbqd_property" != "" ] || continue

            var_set "${prhtbqd_node_namespace}${prhtbqd_property}" "$prhtbqd_property_value"

            prhtbqd_line_properties="${prhtbqd_line_properties} ${prhtbqd_property} "

            [ "$g_trace" != "1" ] || log "Line properties: $prhtbqd_line_properties"
        done

        # Add properties to the list only when line is known and has expected format
        if [ "$prhtbqd_line_unexpected_format" = "1" ]; then
            [ "$g_debug" != "1" ] || log "Line has an unexpected format"
            continue
        fi

        [ "$g_debug" != "1" ] || log "Line properties (final): $prhtbqd_line_properties"

        if [ "$prhtbqd_line_properties" != "" ]; then
            prhtbqd_register_properties="${prhtbqd_register_properties} ${prhtbqd_line_properties}"
        fi        
    done <<EOT
$prhtbqd_node_lines
EOT

    [ "$g_debug" != "1" ] || log "Properties to register: $prhtbqd_register_properties"

    if [ "$prhtbqd_register_properties" != "" ]; then
        register_node_property "$prhtbqd_node_namespace" "$prhtbqd_register_properties" || return $?
    fi
}

##!
##! class htb 1:20 parent 1:1 rate 1659Kbit ceil 6Mbit linklayer ethernet burst 1599b/1 mpu 0b cburst 1599b/1 mpu 0b level 6
##!  Sent 0 bytes 0 pkt (dropped 0, overlimits 0 requeues 0)
##!  backlog 0b 0p requeues 0
##!  lended: 0 borrowed: 0 giants: 0
##!  tokens: 120546 ctokens: 33328
##!
##! class htb 1:160 parent 1:1 leaf 8046: prio 7 quantum 1000 rate 1Kbit ceil 6Mbit linklayer ethernet burst 1600b/1 mpu 0b cburst 1599b/1 mpu 0b level 0
##!  Sent 314 bytes 4 pkt (dropped 0, overlimits 0 requeues 0)
##!  backlog 0b 0p requeues 0
##!  lended: 4 borrowed: 0 giants: 0
##!  tokens: 165641933 ctokens: 31411
##!
##! @param $1 {identifier} - node namespace
##! @param $2 {string} - node lines
##!
parse_htb_class() {
    [ "${1-}" != "" ] || exit_err "parse_htb_class: empty argument 1"
    [ "${2-}" != "" ] || exit_err "parse_htb_class: empty argument 2"

    prhtbcl_node_namespace="$1"
    prhtbcl_node_lines="$2"

    [ "$g_debug" != "1" ] || log "Parsing htb class properties for node namespace '$prhtbcl_node_namespace'"

    prhtbcl_register_properties=""

    prhtbcl_lineno=0

    while IFS="" read -r prhtbcl_line || [ -n "$prhtbcl_line" ]; do
        prhtbcl_lineno=$((prhtbcl_lineno + 1))

        [ "$g_debug" != "1" ] || log "Line num: $prhtbcl_lineno"
        [ "$g_debug" != "1" ] || log "Line content: $prhtbcl_line"

        str_trim_start "prhtbcl_line" "$prhtbcl_line" " " || return $?

        [ "$prhtbcl_line" != "" ] || continue

        prhtbcl_line_first_token=""
        prhtbcl_line_unexpected_format=""
        prhtbcl_line_properties=""
        prhtbcl_expects=""
        prhtbcl_expects_prev=""

        prhtbcl_token_num=0

        for prhtbcl_token in $prhtbcl_line; do
            prhtbcl_token_num=$((prhtbcl_token_num + 1))

            [ "$g_trace" != "1" ] || log "Token num: $prhtbcl_token_num"
            [ "$g_trace" != "1" ] || log "Token value: $prhtbcl_token"

            if [ "$prhtbcl_line_first_token" = "" ]; then
                prhtbcl_line_first_token="$prhtbcl_token"
            fi

            prhtbcl_property=""
            prhtbcl_property_value=""

            case "$prhtbcl_line_first_token" in
                class)
                    case "$prhtbcl_expects" in
                        "")
                            prhtbcl_expects="htb_literal"
                            ;;
                        "htb_literal")
                            prhtbcl_expects="options"
                            ;;
                        "options")
                            case "$prhtbcl_token" in
                                "prio" | "quantum" | "rate" | "overhead" | "ceil" | "linklayer" | "level")
                                    prhtbcl_expects="optval_${prhtbcl_token}"
                                    ;;
                                "burst" | "cburst")
                                    prhtbcl_expects="optval_${prhtbcl_token}"
                                    ;;
                                "mpu")
                                    if [ "$prhtbcl_expects_prev" != "" ]; then
                                        prhtbcl_option="$prhtbcl_expects_prev"
                                        prhtbcl_option="${prhtbcl_option#"optval_"}"

                                        if [ "$prhtbcl_option" != "$prhtbcl_expects_prev" ]; then
                                            prhtbcl_expects="optval_${prhtbcl_option}_mpu"
                                        fi
                                    fi
                                    ;;
                            esac
                            ;;
                        optval_*)
                            prhtbcl_option="$prhtbcl_expects"
                            prhtbcl_option="${prhtbcl_option#"optval_"}"

                            case "$prhtbcl_option" in
                                "prio" | "quantum" | "rate" | "overhead" | "ceil" | "linklayer" | "level")
                                    prhtbcl_property="htb_${prhtbcl_option}"
                                    prhtbcl_property_value="$prhtbcl_token"
                                    ;;
                                "burst" | "cburst" | "burst_mpu" | "cburst_mpu")
                                    prhtbcl_property="htb_${prhtbcl_option}"
                                    prhtbcl_property_value="$prhtbcl_token"
                                    ;;
                            esac

                            # shellcheck disable=SC2034 # appears unused
                            prhtbcl_expects_prev="$prhtbcl_expects"
                            prhtbcl_expects="options"
                            ;;
                        *)
                            prhtbcl_line_unexpected_format="1"
                            break
                            ;;
                    esac
                    ;;
                "lended:" | "tokens:")
                    case "$prhtbcl_expects" in
                        "")
                            prhtbcl_expects="statval_${prhtbcl_line_first_token%":"}"
                            ;;
                        "stats")
                            prhtbcl_token="${prhtbcl_token%":"}"
                            case "$prhtbcl_token" in
                                "lended" | "borrowed" | "giants" | "tokens" | "ctokens")
                                    prhtbcl_expects="statval_${prhtbcl_token}"
                                    ;;
                            esac
                            ;;
                        statval_*)
                            prhtbcl_stat="$prhtbcl_expects"
                            prhtbcl_stat="${prhtbcl_stat#"statval_"}"

                            case "$prhtbcl_stat" in
                                "lended" | "borrowed" | "giants" | "tokens" | "ctokens")
                                    prhtbcl_property="htb_${prhtbcl_stat}"
                                    prhtbcl_property_value="$prhtbcl_token"
                                    ;;
                            esac

                            # shellcheck disable=SC2034 # appears unused
                            prhtbcl_expects_prev="$prhtbcl_expects"
                            prhtbcl_expects="stats"
                            ;;
                        *)
                            prhtbcl_line_unexpected_format="1"
                            break
                            ;;
                    esac
                    ;;
                *)
                    # Unknown line's first token. Break parsing current line and go to the next one.
                    break
                    ;;
            esac

            [ "$g_trace" != "1" ] || log "Property name: $prhtbcl_property"
            [ "$g_trace" != "1" ] || log "Property value: $prhtbcl_property_value"

            [ "$prhtbcl_property" != "" ] || continue

            var_set "${prhtbcl_node_namespace}${prhtbcl_property}" "$prhtbcl_property_value"

            prhtbcl_line_properties="${prhtbcl_line_properties} ${prhtbcl_property} "

            [ "$g_trace" != "1" ] || log "Line properties: $prhtbcl_line_properties"
        done

        # Add properties to the list only when line is known and has expected format
        if [ "$prhtbcl_line_unexpected_format" = "1" ]; then
            [ "$g_debug" != "1" ] || log "Line has an unexpected format"
        fi

        [ "$g_debug" != "1" ] || log "Line properties (final): $prhtbcl_line_properties"

        if [ "$prhtbcl_line_properties" != "" ]; then
            prhtbcl_register_properties="${prhtbcl_register_properties} ${prhtbcl_line_properties}"
        fi        
    done <<EOT
$prhtbcl_node_lines
EOT

    [ "$g_debug" != "1" ] || log "Properties to register: $prhtbcl_register_properties"

    if [ "$prhtbcl_register_properties" != "" ]; then
        register_node_property "$prhtbcl_node_namespace" "$prhtbcl_register_properties" || return $?
    fi
}

##!
##! @param $1 {identifier} - node namespace
##! @param $2 {string} - node type
##! @param $3 {string} - node lines
##!
parse_fq_codel() {
    [ "${1-}" != "" ] || exit_err "parse_fq_codel: empty argument 1"
    [ "${2-}" != "" ] || exit_err "parse_fq_codel: empty argument 2"
    [ "${3-}" != "" ] || exit_err "parse_fq_codel: empty argument 3"

    case "$2" in
        qdisc)
            parse_fq_codel_qdisc "$1" "$3" || return $?
            ;;
        class)
            parse_fq_codel_class "$1" "$3" || return $?
            ;;
        *)
            exit_err "parse_fq_codel: unknown node type: $2"
            ;;
    esac
}

##!
##! qdisc pfifo 8071: parent 1:2 limit 50p
##!  Sent 372 bytes 1 pkt (dropped 0, overlimits 0 requeues 0)
##!  backlog 0b 0p requeues 0
##!
##! qdisc fq_codel 8073: parent 1:11 limit 10240p flows 1024 quantum 757 target 5ms interval 100ms memory_limit 32Mb ecn drop_batch 64
##!  Sent 427987813 bytes 778694 pkt (dropped 3, overlimits 0 requeues 0)
##!  backlog 0b 0p requeues 0
##!   maxpacket 1504 drop_overlimit 0 new_flow_count 21351 ecn_mark 0
##!   new_flows_len 0 old_flows_len 1
##!
##! @param $1 {identifier} - node namespace
##! @param $2 {string} - node lines
##!
parse_fq_codel_qdisc() {
    [ "${1-}" != "" ] || exit_err "parse_fq_codel_qdisc: empty argument 1"
    [ "${2-}" != "" ] || exit_err "parse_fq_codel_qdisc: empty argument 2"

    prfqcdqd_node_namespace="$1"
    prfqcdqd_node_lines="$2"

    [ "$g_debug" != "1" ] || log "Parsing fq_codel qdisc properties for node namespace '$prfqcdqd_node_namespace'"

    prfqcdqd_register_properties=""

    prfqcdqd_lineno=0

    while IFS="" read -r prfqcdqd_line || [ -n "$prfqcdqd_line" ]; do
        prfqcdqd_lineno=$((prfqcdqd_lineno + 1))

        [ "$g_debug" != "1" ] || log "Line num: $prfqcdqd_lineno"
        [ "$g_debug" != "1" ] || log "Line content: $prfqcdqd_line"

        str_trim_start "prfqcdqd_line" "$prfqcdqd_line" " " || return $?

        [ "$prfqcdqd_line" != "" ] || continue

        prfqcdqd_line_first_token=""
        prfqcdqd_line_unexpected_format=""
        prfqcdqd_line_properties=""
        prfqcdqd_expects=""
        prfqcdqd_expects_prev=""

        prfqcdqd_token_num=0

        for prfqcdqd_token in $prfqcdqd_line; do
            prfqcdqd_token_num=$((prfqcdqd_token_num + 1))

            [ "$g_trace" != "1" ] || log "Token num: $prfqcdqd_token_num"
            [ "$g_trace" != "1" ] || log "Token value: $prfqcdqd_token"

            if [ "$prfqcdqd_line_first_token" = "" ]; then
                prfqcdqd_line_first_token="$prfqcdqd_token"
            fi

            prfqcdqd_property=""
            prfqcdqd_property_value=""

            case "$prfqcdqd_line_first_token" in
                qdisc)
                    case "$prfqcdqd_expects" in
                        "")
                            prfqcdqd_expects="fq_codel_literal"
                            ;;
                        "fq_codel_literal")
                            prfqcdqd_expects="options"
                            ;;
                        "options")
                            case "$prfqcdqd_token" in
                                "limit" | "flows" | "quantum" | "target" | "interval" | "memory_limit" | "drop_batch")
                                    prfqcdqd_expects="optval_${prfqcdqd_token}"
                                    ;;
                                ecn)
                                    prfqcdqd_property="fq_codel_ecn"
                                    prfqcdqd_property_value="1"
                                    ;;
                            esac
                            ;;
                        optval_*)
                            prfqcdqd_option="$prfqcdqd_expects"
                            prfqcdqd_option="${prfqcdqd_option#"optval_"}"

                            case "$prfqcdqd_option" in
                                "limit" | "flows" | "quantum" | "target" | "interval" | "memory_limit" | "drop_batch")
                                    prfqcdqd_property="fq_codel_${prfqcdqd_option}"
                                    prfqcdqd_property_value="$prfqcdqd_token"
                                    ;;
                            esac

                            # shellcheck disable=SC2034 # appears unused
                            prfqcdqd_expects_prev="$prfqcdqd_expects"
                            prfqcdqd_expects="options"
                            ;;
                        *)
                            prfqcdqd_line_unexpected_format="1"
                            break
                            ;;
                    esac
                    ;;
                "maxpacket" | "new_flows_len")
                    case "$prfqcdqd_expects" in
                        "")
                            prfqcdqd_expects="statval_$prfqcdqd_line_first_token"
                            ;;
                        "stats")
                            case "$prfqcdqd_token" in
                                "maxpacket" | "drop_overlimit" | "new_flow_count" | "ecn_mark")
                                    prfqcdqd_expects="statval_${prfqcdqd_token}"
                                    ;;
                                "ce_mark" | "memory_used" | "drop_overmemory")
                                    prfqcdqd_expects="statval_${prfqcdqd_token}"
                                    ;;
                                "new_flows_len" | "old_flows_len")
                                    prfqcdqd_expects="statval_${prfqcdqd_token}"
                                    ;;
                            esac
                            ;;
                        statval_*)
                            prfqcdqd_stat="$prfqcdqd_expects"
                            prfqcdqd_stat="${prfqcdqd_stat#"statval_"}"

                            case "$prfqcdqd_stat" in
                                "maxpacket" | "drop_overlimit" | "new_flow_count" | "ecn_mark")
                                    prfqcdqd_property="fq_codel_${prfqcdqd_stat}"
                                    prfqcdqd_property_value="$prfqcdqd_token"
                                    ;;
                                "ce_mark" | "memory_used" | "drop_overmemory")
                                    prfqcdqd_property="fq_codel_${prfqcdqd_stat}"
                                    prfqcdqd_property_value="$prfqcdqd_token"
                                    ;;
                                "new_flows_len" | "old_flows_len")
                                    prfqcdqd_property="fq_codel_${prfqcdqd_stat}"
                                    prfqcdqd_property_value="$prfqcdqd_token"
                                    ;;
                            esac

                            # shellcheck disable=SC2034 # appears unused
                            prfqcdqd_expects_prev="$prfqcdqd_expects"
                            prfqcdqd_expects="stats"
                            ;;
                        *)
                            prfqcdqd_line_unexpected_format="1"
                            break
                            ;;
                    esac
                    ;;
                *)
                    # Unknown line's first token. Break parsing current line and go to the next one.
                    break
                    ;;
            esac

            [ "$g_trace" != "1" ] || log "Property name: $prfqcdqd_property"
            [ "$g_trace" != "1" ] || log "Property value: $prfqcdqd_property_value"

            [ "$prfqcdqd_property" != "" ] || continue

            var_set "${prfqcdqd_node_namespace}${prfqcdqd_property}" "$prfqcdqd_property_value"

            prfqcdqd_line_properties="${prfqcdqd_line_properties} ${prfqcdqd_property} "

            [ "$g_trace" != "1" ] || log "Line properties: $prfqcdqd_line_properties"
        done

        # Add properties to the list only when line is known and has expected format
        if [ "$prfqcdqd_line_unexpected_format" = "1" ]; then
            [ "$g_debug" != "1" ] || log "Line has an unexpected format"
        fi

        [ "$g_debug" != "1" ] || log "Line properties (final): $prfqcdqd_line_properties"

        if [ "$prfqcdqd_line_properties" != "" ]; then
            prfqcdqd_register_properties="${prfqcdqd_register_properties} ${prfqcdqd_line_properties}"
        fi
    done <<EOT
$prfqcdqd_node_lines
EOT

    [ "$g_debug" != "1" ] || log "Properties to register: $prfqcdqd_register_properties"

    if [ "$prfqcdqd_register_properties" != "" ]; then
        register_node_property "$prfqcdqd_node_namespace" "$prfqcdqd_register_properties" || return $?
    fi
}

##!
##! class fq_codel 807b:147 parent 807b:
##!  (dropped 0, overlimits 0 requeues 0)
##!  backlog 0b 0p requeues 0
##!   deficit -854 count 0 lastcount 0 ldelay 4us
##!
##! @param $1 {identifier} - node namespace
##! @param $2 {string} - node lines
##!
parse_fq_codel_class() {
    [ "${1-}" != "" ] || exit_err "parse_fq_codel_class: empty argument 1"
    [ "${2-}" != "" ] || exit_err "parse_fq_codel_class: empty argument 2"

    prfqcdcl_node_namespace="$1"
    prfqcdcl_node_lines="$2"

    [ "$g_debug" != "1" ] || log "Parsing fq_codel class properties for node namespace '$prfqcdcl_node_namespace'"

    prfqcdcl_register_properties=""

    prfqcdcl_lineno=0

    while IFS="" read -r prfqcdcl_line || [ -n "$prfqcdcl_line" ]; do
        prfqcdcl_lineno=$((prfqcdcl_lineno + 1))

        [ "$g_debug" != "1" ] || log "Line num: $prfqcdcl_lineno"
        [ "$g_debug" != "1" ] || log "Line content: $prfqcdcl_line"

        str_trim_start "prfqcdcl_line" "$prfqcdcl_line" " " || return $?

        [ "$prfqcdcl_line" != "" ] || continue

        prfqcdcl_line_first_token=""
        prfqcdcl_line_unexpected_format=""
        prfqcdcl_line_properties=""
        prfqcdcl_expects=""
        prfqcdcl_expects_prev=""

        prfqcdcl_token_num=0

        for prfqcdcl_token in $prfqcdcl_line; do
            prfqcdcl_token_num=$((prfqcdcl_token_num + 1))

            [ "$g_trace" != "1" ] || log "Token num: $prfqcdcl_token_num"
            [ "$g_trace" != "1" ] || log "Token value: $prfqcdcl_token"

            if [ "$prfqcdcl_line_first_token" = "" ]; then
                prfqcdcl_line_first_token="$prfqcdcl_token"
            fi

            prfqcdcl_property=""
            prfqcdcl_property_value=""

            case "$prfqcdcl_line_first_token" in
                "deficit")
                    case "$prfqcdcl_expects" in
                        "")
                            prfqcdcl_expects="statval_$prfqcdcl_line_first_token"
                            ;;
                        "stats")
                            case "$prfqcdcl_token" in
                                "deficit" | "count" | "lastcount" | "ldelay" | "dropping" | "drop_next")
                                    prfqcdcl_expects="statval_${prfqcdcl_token}"
                                    ;;
                            esac
                            ;;
                        statval_*)
                            prfqcdcl_stat="$prfqcdcl_expects"
                            prfqcdcl_stat="${prfqcdcl_stat#"statval_"}"

                            case "$prfqcdcl_stat" in
                                "deficit" | "count" | "lastcount" | "ldelay" | "dropping" | "drop_next")
                                    prfqcdcl_property="fq_codel_${prfqcdcl_stat}"
                                    prfqcdcl_property_value="$prfqcdcl_token"
                                    ;;
                            esac

                            # shellcheck disable=SC2034 # appears unused
                            prfqcdcl_expects_prev="$prfqcdcl_expects"
                            prfqcdcl_expects="stats"
                            ;;
                        *)
                            prfqcdcl_line_unexpected_format="1"
                            break
                            ;;
                    esac
                    ;;
                *)
                    # Unknown line's first token. Break parsing current line and go to the next one.
                    break
                    ;;
            esac

            [ "$g_trace" != "1" ] || log "Property name: $prfqcdcl_property"
            [ "$g_trace" != "1" ] || log "Property value: $prfqcdcl_property_value"

            [ "$prfqcdcl_property" != "" ] || continue

            var_set "${prfqcdcl_node_namespace}${prfqcdcl_property}" "$prfqcdcl_property_value"

            prfqcdcl_line_properties="${prfqcdcl_line_properties} ${prfqcdcl_property} "

            [ "$g_trace" != "1" ] || log "Line properties: $prfqcdcl_line_properties"
        done

        # Add properties to the list only when line is known and has expected format
        if [ "$prfqcdcl_line_unexpected_format" = "1" ]; then
            [ "$g_debug" != "1" ] || log "Line has an unexpected format"
        fi

        [ "$g_debug" != "1" ] || log "Line properties (final): $prfqcdcl_line_properties"

        if [ "$prfqcdcl_line_properties" != "" ]; then
            prfqcdcl_register_properties="${prfqcdcl_register_properties} ${prfqcdcl_line_properties}"
        fi
    done <<EOT
$prfqcdcl_node_lines
EOT

    [ "$g_debug" != "1" ] || log "Properties to register: $prfqcdcl_register_properties"

    if [ "$prfqcdcl_register_properties" != "" ]; then
        register_node_property "$prfqcdcl_node_namespace" "$prfqcdcl_register_properties" || return $?
    fi
}

##!
##! @param $1 {number} - snapshot number
##! @param $2 {number} - interface number
##!
build_interface_tree() {
    [ "${1-}" != "" ] || exit_err "build_interface_tree: empty argument 1"
    [ "${2-}" != "" ] || exit_err "build_interface_tree: empty argument 2"

    bdnftr_snapshot_num="$1"
    bdnftr_iface_num="$2"

    [ "$g_benchmark" != "1" ] || tmr_build_iface_tree_total="$(print_time_ms)"

    bdnftr_iface_name=""
    [ "$g_debug" != "1" ] || get_interface_name "bdnftr_iface_name" "$bdnftr_iface_num"

    [ "$g_debug" != "1" ] || log "Building tree of nodes within interface: $bdnftr_iface_name ($bdnftr_iface_num)"

    bdnftr_interface_namespace=""
    make_interface_namespace \
        "bdnftr_interface_namespace" \
        "$bdnftr_snapshot_num" \
        "$bdnftr_iface_num" || return $?

    [ "$g_debug" != "1" ] || log "Interface namespace: $bdnftr_interface_namespace"

    #
    # Clear previous tree's data (if any has been built earlier)
    #

    var_set "${bdnftr_interface_namespace}root_qdisc_id" ""

    #
    # Check for each qdisc and class if it has a parent.
    # If it does then add it as a child of that parent node.
    #

    bdnftr_seen_parents=""

    for bdnftr_node_type in qdisc class; do
        [ "$g_debug" != "1" ] || log "Iterating for children over '$bdnftr_node_type'"

        bdnftr_nodes_ids=""

        case "$bdnftr_node_type" in
            qdisc)
                var_set_expanded "bdnftr_nodes_ids" "${bdnftr_interface_namespace}qdiscs_ids" || return $?
                ;;
            class)
                var_set_expanded "bdnftr_nodes_ids" "${bdnftr_interface_namespace}classes_ids" || return $?
                ;;
            *)
                exit_err "build_interface_tree: unknown node type: $bdnftr_node_type"
                ;;
        esac

        [ "$g_debug" != "1" ] || log "List of ids: $bdnftr_nodes_ids"

        [ "$g_benchmark" != "1" ] || tmr_interface_tree="$(print_time_ms)"

        for bdnftr_node_id in $bdnftr_nodes_ids; do
            [ "$g_debug" != "1" ] || log "Checking if '$bdnftr_node_type $bdnftr_node_id' is a child of something"

            if [ "$bdnftr_node_id" = "ffff" ]; then
                [ "$g_debug" != "1" ] || log "Node is an ingress and has an internal parent. Skipping."
                continue
            fi

            # This must not fail. No failover.
            # Building happens only for the actual snapshot. Node/namespace must always exist and be registered.
            bdnftr_node_namespace=""
            find_node_namespace_by_id \
                "bdnftr_node_namespace" \
                "$bdnftr_snapshot_num" \
                "$bdnftr_iface_num" \
                "$bdnftr_node_id" || return $?

            [ "$g_debug" != "1" ] || log "Node namespace: $bdnftr_node_namespace"

            # Cheap operation: non-conditional
            remove_node_property "$bdnftr_node_namespace" "children" || return $?

            bdnftr_node_parent=""
            var_set_expanded "bdnftr_node_parent" "${bdnftr_node_namespace}parent" || return $?

            case "$bdnftr_node_type" in
                qdisc)
                    # Only the root qdisc does not have a parent. Set it as a `root_qdisc_id`.
                    if [ "$bdnftr_node_parent" = "" ]; then
                        var_set "${bdnftr_interface_namespace}root_qdisc_id" "$bdnftr_node_id"

                        register_interface_property \
                            "$bdnftr_interface_namespace" \
                            "root_qdisc_id" || return $?

                        set_node_property "$bdnftr_node_namespace" "parent_id" "" || return $?

                        [ "$g_debug" != "1" ] || log "Node has no parent. Skipping."

                        continue
                    fi

                    # The rest of qdiscs always have a parent class.
                    bdnftr_node_parent_major=""
                    var_set_expanded \
                        "bdnftr_node_parent_major" \
                        "${bdnftr_node_namespace}parent_major" || return $?

                    bdnftr_node_parent_minor=""
                    var_set_expanded \
                        "bdnftr_node_parent_minor" \
                        "${bdnftr_node_namespace}parent_minor" || return $?

                    # Parent is always a class therefore id is in form of 'major_minor'.
                    bdnftr_parent_id="${bdnftr_node_parent_major}_${bdnftr_node_parent_minor}"
                    ;;
                class)
                    bdnftr_node_handle_major=""
                    var_set_expanded \
                        "bdnftr_node_handle_major" \
                        "${bdnftr_node_namespace}handle_major" || return $?

                    # Class is always a child of something.
                    # If class is a child of root qdisc then this class is also "root" in tc-output and has no parent property.
                    # But qdiscs and classes share the same major number so class' parent is qdisc with handle 'major:0'.
                    # And this qdisc's id will be just 'major'.
                    if [ "$bdnftr_node_parent" = "" ]; then
                        bdnftr_parent_id="${bdnftr_node_handle_major}"

                        # Also update parent properties and set "real" values so they can be used in templates/filters
                        var_set "${bdnftr_node_namespace}parent" "${bdnftr_node_handle_major}:0"
                        var_set "${bdnftr_node_namespace}parent_major" "$bdnftr_node_handle_major"
                        var_set "${bdnftr_node_namespace}parent_minor" "0"
                    else
                        bdnftr_node_parent_major=""
                        var_set_expanded "bdnftr_node_parent_major" "${bdnftr_node_namespace}parent_major" || return $?

                        bdnftr_node_parent_minor=""
                        var_set_expanded "bdnftr_node_parent_minor" "${bdnftr_node_namespace}parent_minor" || return $?

                        if [ "$bdnftr_node_parent_minor" = "0" ]; then
                            bdnftr_parent_id="${bdnftr_node_parent_major}"
                        else
                            bdnftr_parent_id="${bdnftr_node_parent_major}_${bdnftr_node_parent_minor}"
                        fi
                    fi
                    ;;
                *)
                    exit_err "build_interface_tree: unknown node type: $bdnftr_node_type"
                    ;;
            esac

            [ "$g_debug" != "1" ] || log "Parent id: $bdnftr_parent_id"

            set_node_property "$bdnftr_node_namespace" "parent_id" "$bdnftr_parent_id" || return $?

            bdnftr_parent_children=""

            if [ "${bdnftr_seen_parents#*" $bdnftr_parent_id "}" = "$bdnftr_seen_parents" ]; then
                bdnftr_seen_parents="${bdnftr_seen_parents} $bdnftr_parent_id "
            else
                var_set_expanded "bdnftr_parent_children" "bdnftr_node${bdnftr_parent_id}_children" || return $?
            fi

            [ "$g_debug" != "1" ] || log "Parent is '$bdnftr_parent_id' and its children before: $bdnftr_parent_children"

            bdnftr_parent_children="${bdnftr_parent_children}${bdnftr_parent_children:+" "}${bdnftr_node_id}"
            var_set "bdnftr_node${bdnftr_parent_id}_children" "$bdnftr_parent_children"

            [ "$g_debug" != "1" ] || log "Parent is '$bdnftr_parent_id' and its children after: $bdnftr_parent_children"
        done

        [ "$g_benchmark" != "1" ] || log "Scanned '$bdnftr_node_type' for children: $(($(print_time_ms) - tmr_interface_tree)) ms"
    done

    for bdnftr_parent_id in $bdnftr_seen_parents; do
        # This must not fail. No failover.
        # Building happens only for the actual snapshot. Node/namespace must always exist and be registered.
        bdnftr_parent_namespace=""
        find_node_namespace_by_id \
            "bdnftr_parent_namespace" \
            "$bdnftr_snapshot_num" \
            "$bdnftr_iface_num" \
            "$bdnftr_parent_id" || return $?

        [ "$g_debug" != "1" ] || log "Parent namespace: $bdnftr_parent_namespace"

        bdnftr_parent_children=""
        var_set_expanded "bdnftr_parent_children" "bdnftr_node${bdnftr_parent_id}_children" || return $?

        [ "$g_debug" != "1" ] || log "Parent children: $bdnftr_parent_children"

        set_node_property "$bdnftr_parent_namespace" "children" "$bdnftr_parent_children" || return $?
    done

    [ "$g_benchmark" != "1" ] || log "[BLOCK] BUILD INTERFACE TREE: $(($(print_time_ms) - tmr_build_iface_tree_total)) ms"
}

##!
##! @param $1 {identifier} - result out variable name
##! @param $2 {number} - snapshot number
##! @param $3 {number} - interface number
##! @param $4 {string} - node id
##! @param $5 {string} - node children
##!
filter_node_children() {
    [ "${1-}" != "" ] || exit_err "filter_node_children: empty argument 1"
    [ "${2-}" != "" ] || exit_err "filter_node_children: empty argument 2"
    [ "${3-}" != "" ] || exit_err "filter_node_children: empty argument 3"
    [ "${4-}" != "" ] || exit_err "filter_node_children: empty argument 4"
    [ "${5-}" != "" ] || exit_err "filter_node_children: empty argument 5"

    ftndcr_snapshot_num="$2"
    ftndcr_iface_num="$3"
    ftndcr_node_id="$4"
    ftndcr_node_children="$5"

    [ "$g_benchmark" != "1" ] || tmr_node_filter_children="$(print_time_ms)"

    [ "$g_debug" != "1" ] || log "Filtering '$ftndcr_node_id' children: $ftndcr_node_children"

    ftndcr_result=""

    for ftndcr_child_id in $ftndcr_node_children; do
        [ "$g_debug" != "1" ] || log "Child ID: $ftndcr_child_id"

        # This must not fail. No failover.
        # Filtering happens only for the actual snapshot. Node/namespace must always exist and be registered.
        ftndcr_child_namespace=""
        find_node_namespace_by_id \
            "ftndcr_child_namespace" \
            "$ftndcr_snapshot_num" \
            "$ftndcr_iface_num" \
            "$ftndcr_child_id" || return $?

        [ "$g_debug" != "1" ] || log "Child namespace: $ftndcr_child_namespace"

        ftndcr_child_type=""
        var_set_expanded "ftndcr_child_type" "${ftndcr_child_namespace}type" || return $?

        [ "$g_debug" != "1" ] || log "Child type: $ftndcr_child_type"

        ftndcr_matched=""

        for ftndcr_filter_type in $ftndcr_child_type common; do
            case "$ftndcr_filter_type" in
                common)
                    ftndcr_filters_prefix="g_hide_common"
                    ftndcr_filters_count="$g_hide_common_count"
                    ;;
                qdisc)
                    ftndcr_filters_prefix="g_hide_qdiscs"
                    ftndcr_filters_count="$g_hide_qdiscs_count"
                    ;;
                class)
                    ftndcr_filters_prefix="g_hide_classes"
                    ftndcr_filters_count="$g_hide_classes_count"
                    ;;
                *)
                    exit_err "filter_node_children: unknown filter type: $ftndcr_filter_type"
                    ;;
            esac

            [ "$g_debug" != "1" ] || log "Filters prefix: $ftndcr_filters_prefix"
            [ "$g_debug" != "1" ] || log "Filters count: $ftndcr_filters_count"

            ftndcr_filter_idx=0

            while [ "$ftndcr_filter_idx" -lt "$ftndcr_filters_count" ]; do
                ftndcr_filter_idx=$((ftndcr_filter_idx + 1))

                [ "$g_debug" != "1" ] || log "Evaluating filter $ftndcr_filter_idx"

                ftndcr_condition=""
                var_set_expanded "ftndcr_condition" "${ftndcr_filters_prefix}${ftndcr_filter_idx}" || return $?

                [ "$g_debug" != "1" ] || log "Filter condition: $ftndcr_condition"

                str_trim_start "ftndcr_condition" "$ftndcr_condition" " " || return $?

                [ "$ftndcr_condition" != "" ] || continue

                ftndcr_eval_status=0
                evaluate_node_condition \
                    "ftndcr_matched" \
                    "$ftndcr_snapshot_num" \
                    "$ftndcr_iface_num" \
                    "$ftndcr_child_id" \
                    "$ftndcr_condition" || ftndcr_eval_status=$?

                if [ "$ftndcr_eval_status" != "0" ]; then
                    [ "$g_debug" != "1" ] || log "Evaluating error: $ftndcr_eval_status"
                    continue
                fi

                if [ "$ftndcr_matched" = "1" ]; then
                    [ "$g_debug" != "1" ] || log "There is already a match for this child. No need to check other filters"
                    break 2
                fi
            done
        done

        if [ "$ftndcr_matched" = "1" ]; then
            [ "$g_debug" != "1" ] || log "Filter has been matched. Do not add '$ftndcr_child_id' to the list of visible children"
            continue
        fi

        [ "$g_debug" != "1" ] || log "No filter has been matched. Adding '$ftndcr_child_id' to the list of visible children"

        ftndcr_result="${ftndcr_result}${ftndcr_result:+" "}${ftndcr_child_id}"
    done

    var_set "$1" "$ftndcr_result"

    [ "$g_debug" != "1" ] || log "Visible children of '$ftndcr_node_id': $ftndcr_result"

    [ "$g_benchmark" != "1" ] || log "Filtered children of '$ftndcr_node_id': $(($(print_time_ms) - tmr_node_filter_children)) ms"
}

##!
##! @param $1 {identifier} - result out variable name
##! @param $2 {number} - interface number
##! @param $3 {string} - node id
##! @param $4 {string} - node children
##!
sort_node_children() {
    [ "${1-}" != "" ] || exit_err "sort_node_children: empty argument 1"
    [ "${2-}" != "" ] || exit_err "sort_node_children: empty argument 2"
    [ "${3-}" != "" ] || exit_err "sort_node_children: empty argument 3"
    [ "${4-}" != "" ] || exit_err "sort_node_children: empty argument 4"

    # stndcr_iface_num="$2"
    stndcr_node_id="$3"
    stndcr_node_children="$4"

    [ "$g_benchmark" != "1" ] || tmr_node_sort_children="$(print_time_ms)"

    [ "$g_debug" != "1" ] || log "Sorting '$stndcr_node_id' children: $stndcr_node_children"

    stndcr_children_int=""
    stndcr_children_major0=""

    for stndcr_child_id in $stndcr_node_children; do
        if [ "${stndcr_child_id#*"_"}" != "$stndcr_child_id" ]; then
            # major_minor
            stndcr_major_int=""
            hex_to_int "stndcr_major_int" "${stndcr_child_id%"_"*}" || return $?
            stndcr_minor_int=""
            hex_to_int "stndcr_minor_int" "${stndcr_child_id#*"_"}" || return $?
        else
            # Either major, or 0X (for major number 0)
            if [ "${stndcr_child_id#"0"}" != "$stndcr_child_id" ]; then
                # Qdiscs with internal major number '0' have node id equal to "0" + inttostr((0xffff + 1) + qdisc_num)
                stndcr_major_int="0"
                stndcr_children_major0="${stndcr_children_major0} ${stndcr_child_id}"
            else
                stndcr_major_int=""
                hex_to_int "stndcr_major_int" "$stndcr_child_id" || return $?
            fi
            stndcr_minor_int="0"
        fi

        # Do not sort major0 children, they'll be prepended to the sorted list
        if [ "$stndcr_major_int" = "0" ] && [ "$stndcr_minor_int" = "0" ]; then
            continue
        fi

        stndcr_id_int=$((stndcr_major_int * 0xffff + stndcr_minor_int))

        [ "$g_debug" != "1" ] || log "Child id '$stndcr_child_id' as int: $stndcr_id_int"

        var_set "stndcr_child${stndcr_id_int}" "$stndcr_child_id"

        stndcr_children_int="${stndcr_children_int}${stndcr_children_int:+" "}${stndcr_id_int}"
    done

    stndcr_sorted_int=""

    stndcr_processed_children=""

    for _ in $stndcr_children_int; do
        stndcr_min_id_int=""

        for stndcr_child_id_int in $stndcr_children_int; do
            if str_contains "$stndcr_processed_children" ":${stndcr_child_id_int}:"; then
                continue
            fi

            if [ "$stndcr_min_id_int" = "" ] || [ "$stndcr_child_id_int" -lt "$stndcr_min_id_int" ]; then
                stndcr_min_id_int="$stndcr_child_id_int"
            fi
        done

        [ "$g_debug" != "1" ] || log "Minimal int id found: $stndcr_min_id_int"

        stndcr_processed_children="${stndcr_processed_children}:${stndcr_min_id_int}:"

        [ "$g_debug" != "1" ] || log "Processed int ids: $stndcr_processed_children"

        stndcr_sorted_int="${stndcr_sorted_int}${stndcr_sorted_int:+" "}${stndcr_min_id_int}"
    done

    [ "$g_debug" != "1" ] || log "Sorted int ids: $stndcr_sorted_int"

    stndcr_sorted=""

    for stndcr_child_id in $stndcr_children_major0; do
        stndcr_sorted="${stndcr_sorted}${stndcr_sorted:+" "}${stndcr_child_id}"
    done

    for stndcr_child_id_int in $stndcr_sorted_int; do
        stndcr_child_id=""
        var_set_expanded "stndcr_child_id" "stndcr_child${stndcr_child_id_int}" || return $?

        stndcr_sorted="${stndcr_sorted}${stndcr_sorted:+" "}${stndcr_child_id}"
    done

    var_set "$1" "$stndcr_sorted"

    [ "$g_debug" != "1" ] || log "Sorted '$stndcr_node_id' children: $stndcr_sorted"
    [ "$g_benchmark" != "1" ] || log "Sorted children of '$stndcr_node_id': $(($(print_time_ms) - tmr_node_sort_children)) ms"
}

#
# RENDER
# ==============================================================================

##!
##! @param $1 {identifier} - result out variable name
##! @param $2 {number} - snapshot number
##! @param $3 {number} - interface number
##! @param $4 {string} - node handle/id
##! @return ERR_NODE_INVALID_HANDLE
##!
render_interface_node() {
    [ "${1-}" != "" ] || exit_err "render_interface_node: empty argument 1"
    [ "${2-}" != "" ] || exit_err "render_interface_node: empty argument 2"
    [ "${3-}" != "" ] || exit_err "render_interface_node: empty argument 3"
    [ "${4+a}" != "" ] || exit_err "render_interface_node: argument 4 must be specified"

    rntfnd_snapshot_num="$2"
    rntfnd_iface_num="$3"
    rntfnd_handle_or_id="$4"

    [ "$g_benchmark" != "1" ] || tmr_render_iface_node_total="$(print_time_ms)"

    rntfnd_iface_name=""
    [ "$g_debug" != "1" ] || get_interface_name "rntfnd_iface_name" "$rntfnd_iface_num"

    [ "$g_debug" != "1" ] || log "Rendering '${rntfnd_iface_name}${rntfnd_handle_or_id:+"/$rntfnd_handle_or_id"}'"

    rntfnd_interface_namespace=""
    make_interface_namespace "rntfnd_interface_namespace" "$rntfnd_snapshot_num" "$rntfnd_iface_num" || return $?

    [ "$g_debug" != "1" ] || log "Interface namespace: $rntfnd_interface_namespace"

    [ "$g_debug" != "1" ] || log "Resolving node: $rntfnd_handle_or_id"

    rntfnd_node_id=""
    rntfnd_render_ingress=""

    if [ "$rntfnd_handle_or_id" = "" ]; then
        # Root qdisc
        var_exists "${rntfnd_interface_namespace}root_qdisc_id" || return "$ERR_INTERFACE_ROOT_QDISC_NOT_SET"
        var_set_expanded "rntfnd_node_id" "${rntfnd_interface_namespace}root_qdisc_id" || return "$ERR_INTERFACE_ROOT_QDISC_NOT_SET"
        var_set_expanded "rntfnd_render_ingress" "${rntfnd_interface_namespace}has_ingress" || return $?
    elif [ "${rntfnd_handle_or_id#*":"}" != "$rntfnd_handle_or_id" ]; then
        # Handle
        rntfnd_node_handle=""
        canonicalize_handle "rntfnd_node_handle" "$rntfnd_handle_or_id" || return "$ERR_NODE_INVALID_HANDLE"

        rntfnd_node_handle_major=""
        rntfnd_node_handle_minor=""
        parse_handle "rntfnd_node_handle_" "$rntfnd_node_handle" || return "$ERR_NODE_INVALID_HANDLE"

        if [ "$rntfnd_node_handle_minor" = "0" ]; then
            rntfnd_node_id="$rntfnd_node_handle_major"
        else
            rntfnd_node_id="${rntfnd_node_handle_major}_${rntfnd_node_handle_minor}"
        fi
    else
        # Id: strip qdiscs-only "_0"/"_" suffixes if exist
        rntfnd_node_id="$rntfnd_handle_or_id"
        rntfnd_node_id="${rntfnd_node_id%"_0"}"
        rntfnd_node_id="${rntfnd_node_id%"_"}"
    fi

    [ "$g_debug" != "1" ] || log "Resolved node id: $rntfnd_node_id"

    rntfnd_buffer=""

    if [ "$rntfnd_node_id" != "" ]; then
        _render_node \
            "rntfnd_buffer" \
            "$rntfnd_snapshot_num" \
            "$rntfnd_iface_num" \
            "$rntfnd_node_id" \
            1 \
            "" \
            "" || return $?
    fi

    # It should/will be printed only when provided id was empty
    if [ "$rntfnd_render_ingress" = "1" ]; then
        _render_node \
            "rntfnd_buffer" \
            "$rntfnd_snapshot_num" \
            "$rntfnd_iface_num" \
            "ffff" \
            1 \
            "" \
            "" || return $?
    fi

    if [ "$rntfnd_buffer" != "" ]; then
        rntfnd_buffer="${rntfnd_buffer%"$TCTREE_NL"}${TCTREE_NL}"
    fi

    var_set "$1" "$rntfnd_buffer"

    [ "$g_benchmark" != "1" ] || log "[BLOCK] RENDER TARGET: $(($(print_time_ms) - tmr_render_iface_node_total)) ms"
}

##!
##! @param $1 {identifier} - initialized buffer out variable name
##! @param $2 {number} - snapshot number
##! @param $3 {number} - interface number
##! @param $4 {string} - node id
##! @param $5 {number} - level
##! @param $6 {string} - parent children
##! @param $7 {string} - parents siblings "bit map"
##!
_render_node() {
    [ "${1-}" != "" ] || exit_err "_render_node: empty argument 1"
    [ "${2-}" != "" ] || exit_err "_render_node: empty argument 2"
    [ "${3-}" != "" ] || exit_err "_render_node: empty argument 3"
    [ "${4-}" != "" ] || exit_err "_render_node: empty argument 4"
    [ "${5-}" != "" ] || exit_err "_render_node: empty argument 5"
    [ "${6+a}" != "" ] || exit_err "_render_node: argument 6 must be specified"
    [ "${7+a}" != "" ] || exit_err "_render_node: argument 7 must be specified"

    rndnd_snapshot_num="$2"
    rndnd_iface_num="$3"
    rndnd_node_id="$4"
    rndnd_level="$5"
    rndnd_parent_children="$6"
    rndnd_parents_siblings="$7"

    [ "$g_benchmark" != "1" ] || tmr_render_node="$(print_time_ms)"

    [ "$g_debug" != "1" ] || log "Rendering node: $rndnd_node_id"

    [ "$g_debug" != "1" ] || log "Sibling nodes: $rndnd_parent_children"
    [ "$g_debug" != "1" ] || log "Parents have sibling nodes: $rndnd_parents_siblings"

    # This must not fail. No failover.
    # Rendering happens only for the actual snapshot. Node/namespace must always exist and be registered.
    rndnd_node_namespace=""
    rndnd_node_namespace_status=0
    find_node_namespace_by_id \
        "rndnd_node_namespace" \
        "$rndnd_snapshot_num" \
        "$rndnd_iface_num" \
        "$rndnd_node_id" || rndnd_node_namespace_status=$?

    if [ "$rndnd_node_namespace_status" != "0" ]; then
        rndnd_buffer=""
        var_set_expanded "rndnd_buffer" "$1" || return $?

        var_set "$1" "${rndnd_buffer}<node '$rndnd_node_id' not found>$TCTREE_NL"
        
        return 0

        # return "$rndnd_node_namespace_status"
    fi

    [ "$g_debug" != "1" ] || log "Node namespace: $rndnd_node_namespace"

    rndnd_node_type=""
    var_set_expanded "rndnd_node_type" "${rndnd_node_namespace}type" || return $?

    [ "$g_debug" != "1" ] || log "Node type: $rndnd_node_type"

    rndnd_node_kind=""
    var_set_expanded "rndnd_node_kind" "${rndnd_node_namespace}kind" || return $?

    [ "$g_debug" != "1" ] || log "Node kind: $rndnd_node_kind"

    rndnd_node_has_sibling="0"

    if [ "${rndnd_parent_children#"$rndnd_node_id "}" != "$rndnd_parent_children" ] ||
        [ "${rndnd_parent_children#*" $rndnd_node_id "}" != "$rndnd_parent_children" ]
    then
        rndnd_node_has_sibling="1"
    fi

    #
    # Resolve visible children.
    # Node children may affect how the node itself is rendered.
    # There are some options to hide nodes therefore only visible children must be taken into account.
    #

    rndnd_node_children=""
    rndnd_node_visible_children=""

    if var_exists "${rndnd_node_namespace}children"; then
        rndnd_node_children=""
        var_set_expanded "rndnd_node_children" "${rndnd_node_namespace}children" || return $?

        [ "$g_debug" != "1" ] || log "Node children: $rndnd_node_children"

        filter_node_children \
            "rndnd_node_visible_children" \
            "$rndnd_snapshot_num" \
            "$rndnd_iface_num" \
            "$rndnd_node_id" \
            "$rndnd_node_children" || return $?
    fi

    #
    # Make base indent guides
    #
    #    this
    # [|   |   ]|
    # [|   |   ]+-- text
    # [|   |   ]|   |
    # [|   |   ]|   +--
    #

    rndnd_base_indent=""
    rndnd_base_indent_chars=0

    if [ "$rndnd_level" -gt 1 ]; then
        rndnd_idx=0

        for rndnd_sibling_bit in $rndnd_parents_siblings; do
            rndnd_idx=$((rndnd_idx + 1))

            [ "$rndnd_idx" -gt 1 ] || continue

            if [ "$rndnd_sibling_bit" = "1" ]; then
                rndnd_base_indent="${rndnd_base_indent}${g_indent_guide_vert_padded}"
                rndnd_base_indent_chars=$((rndnd_base_indent_chars + g_indent_guide_vert_padded_chars))
            else
                rndnd_base_indent="${rndnd_base_indent}${g_indent_guide_space_padded}"
                rndnd_base_indent_chars=$((rndnd_base_indent_chars + g_indent_guide_space_padded_chars))
            fi
        done
    fi

    [ "$g_debug" != "1" ] || log "Base indent: $rndnd_base_indent"

    #
    # Generate node text
    #

    rndnd_template=""
    rndnd_template_resolved=""

    # Template choosing order:
    # - Type+kind (--template-qdisc-htb, --template-class-htb)
    # - Kind (--template-htb)
    # - Type (--template-qdisc, --template-class)
    # - Common (--template)
    # - Default
    if [ "$g_custom_template_set" = "1" ]; then
        rndnd_template_resolved="1"

        rndnd_type_kind_template="g_template_${rndnd_node_type}_${rndnd_node_kind}"
        rndnd_kind_template="g_template_common_${rndnd_node_kind}"
        rndnd_type_template="g_template_${rndnd_node_type}"

        if var_exists "$rndnd_type_kind_template"; then
            var_set_expanded "rndnd_template" "$rndnd_type_kind_template" || return $?
        elif var_exists "$rndnd_kind_template"; then
            var_set_expanded "rndnd_template" "$rndnd_kind_template" || return $?
        elif var_exists "$rndnd_type_template"; then
            var_set_expanded "rndnd_template" "$rndnd_type_template" || return $?
        elif var_exists "g_template_common"; then
            rndnd_template="$g_template_common"
        else
            rndnd_template_resolved=""
        fi
    fi

    if [ "$rndnd_template_resolved" != "1" ]; then
        case "$rndnd_node_type" in
            qdisc)
                if [ "$g_watch_mode" = "1" ]; then
                    rndnd_template="$TCTREE_DEFAULT_TEMPLATE_QDISC_WATCH"
                else
                    rndnd_template="$TCTREE_DEFAULT_TEMPLATE_QDISC"
                fi
                ;;
            class)
                if [ "$g_watch_mode" = "1" ]; then
                    rndnd_template="$TCTREE_DEFAULT_TEMPLATE_CLASS_WATCH"
                else
                    rndnd_template="$TCTREE_DEFAULT_TEMPLATE_CLASS"
                fi
                ;;
            *)
                exit_err "_render_node: unknown node type: $rndnd_node_type"
                ;;
        esac
    fi

    [ "$g_debug" != "1" ] || log "Selected template: $rndnd_template"

    rndnd_node_template_indent="$rndnd_base_indent_chars"

    if [ "$rndnd_level" -gt 1 ]; then
        rndnd_node_template_indent=$((rndnd_node_template_indent + g_indent_guide_length))
    fi

    rndnd_node_text=""
    rndnd_node_text_status="0"
    render_node_template \
        "rndnd_node_text" \
        "$rndnd_snapshot_num" \
        "$rndnd_iface_num" \
        "$rndnd_node_id" \
        "$rndnd_template" \
        "$rndnd_node_template_indent" || rndnd_node_text_status=$?

    if [ "$rndnd_node_text_status" != "0" ]; then
        rndnd_node_text="<node '$rndnd_node_id' cannot be rendered: error $rndnd_node_text_status>"
    fi

    [ "$g_debug" != "1" ] || log "Node text: $rndnd_node_text"

    # Cannot test by "${text%%"$TCTREE"}" because `%%` trims only single "\n"
    rndnd_node_text_blank="1"

    case "$rndnd_node_text" in
        *[!"$TCTREE_NL"]*)
            rndnd_node_text_blank=""
            ;;
    esac

    #
    # Prepend each line of node text with its indent guides
    #

    rndnd_own_content=""
    rndnd_line_no=0
    rndnd_branch_line_no=""
    rndnd_text_nl_content=""
    rndnd_trailing_nl_content=""

    rndnd_trailing_nl_graphics=""
    [ "$rndnd_node_visible_children" = "" ] || rndnd_trailing_nl_graphics="$g_indent_guide_vert_padded"

    while IFS="" read -r rndnd_node_line || [ -n "$rndnd_node_line" ]; do
        rndnd_line_no=$((rndnd_line_no + 1))

        rndnd_line_empty=""
        [ "$rndnd_node_line" != "" ] || rndnd_line_empty="1"

        if [ "$rndnd_branch_line_no" = "" ]; then
            if [ "$rndnd_line_empty" != "1" ] || [ "$rndnd_node_text_blank" = "1" ]; then
                rndnd_branch_line_no="$rndnd_line_no"
            fi
        fi

        rndnd_line_indent="$rndnd_base_indent"

        #
        # Branch level, above and below.
        # Make indents.
        #
        #          this
        # |   |   [|   ]
        # |   |   [+-- ]text
        # |   |   [|   ]|
        # |   |   [|   ]+--
        #

        # Top-level node (level=1) has no graphics at this level.
        if [ "$rndnd_level" -gt 1 ]; then
            if [ "$rndnd_branch_line_no" = "" ]; then
                # No text has been seen yet
                rndnd_line_indent="${rndnd_line_indent}${g_indent_guide_vert_padded}"
            elif [ "$rndnd_branch_line_no" = "$rndnd_line_no" ]; then
                # First non-empty line of the text
                if [ "$rndnd_node_has_sibling" = "1" ]; then
                    rndnd_line_indent="${rndnd_line_indent}${g_indent_guide_branch_sibling_padded}"
                else
                    rndnd_line_indent="${rndnd_line_indent}${g_indent_guide_branch_padded}"
                fi
            elif [ "$rndnd_node_has_sibling" = "1" ]; then
                # Parent has more siblings after the current node
                rndnd_line_indent="${rndnd_line_indent}${g_indent_guide_vert_padded}"
            else
                # Otherwise just add spaces
                rndnd_line_indent="${rndnd_line_indent}${g_indent_guide_space_padded}"
            fi
        fi

        #
        # Text level, above and below.
        # Add text and/or graphics to the line.
        # Append this line to the node's own content.
        #
        #              this
        # |   |   |   [    ]
        # |   |   +-- [text]
        # |   |   |   [|   ]
        # |   |   |   [+-- ]
        #

        if [ "$rndnd_branch_line_no" = "" ]; then
            # For leading empty lines add parents indents only
            rndnd_own_content="${rndnd_own_content}${rndnd_line_indent}${TCTREE_NL}"
        else
            if [ "$rndnd_line_empty" != "1" ]; then
                if [ "$rndnd_text_nl_content" != "" ]; then
                    rndnd_own_content="${rndnd_own_content}${rndnd_text_nl_content}"
                    rndnd_text_nl_content=""
                fi
                rndnd_trailing_nl_content=""
                rndnd_own_content="${rndnd_own_content}${rndnd_line_indent}${rndnd_node_line}${TCTREE_NL}"
            else
                rndnd_text_nl_content="${rndnd_text_nl_content}${rndnd_line_indent}${TCTREE_NL}"
                rndnd_trailing_nl_content="${rndnd_trailing_nl_content}${rndnd_line_indent}${rndnd_trailing_nl_graphics}${TCTREE_NL}"
            fi
        fi
    done <<EOT
$rndnd_node_text
EOT

    if [ "$rndnd_node_text_blank" = "1" ] && [ "$rndnd_text_nl_content" != "" ]; then
        rndnd_own_content="${rndnd_own_content}${rndnd_text_nl_content}"
    elif [ "$rndnd_trailing_nl_content" != "" ]; then
        rndnd_own_content="${rndnd_own_content}${rndnd_trailing_nl_content}"
    fi

    #
    # Add node's own content to the buffer
    #

    rndnd_buffer=""
    var_set_expanded "rndnd_buffer" "$1" || return $?

    var_set "$1" "${rndnd_buffer}${rndnd_own_content}"

    [ "$g_benchmark" != "1" ] || log "Rendered node '$rndnd_node_id' itself: $(($(print_time_ms) - tmr_render_node)) ms"

    #
    # Render node's visible children
    # If there are no visible children then just return.
    # Otherwise sort visible children and render each of them.
    #

    if [ "$rndnd_node_visible_children" = "" ]; then
        return 0
    fi

    # If there is only one child then no need to sort it
    if [ "${rndnd_node_visible_children#*" "}" != "$rndnd_node_visible_children" ]; then
        rndnd_sorted_children=""
        sort_node_children \
            "rndnd_sorted_children" \
            "$rndnd_iface_num" \
            "$rndnd_node_id" \
            "$rndnd_node_visible_children" || return $?
    else
        rndnd_sorted_children="$rndnd_node_visible_children"
    fi

    rndnd_parents_new_siblings="${rndnd_parents_siblings}${rndnd_parents_siblings:+" "}${rndnd_node_has_sibling}"

    # This will call current function _recursively_ and therefore must be the last operation in the function
    _render_node_children \
        "$1" \
        "$rndnd_snapshot_num" \
        "$rndnd_iface_num" \
        "$rndnd_node_id" \
        "$rndnd_level" \
        "$rndnd_sorted_children" \
        "$rndnd_parents_new_siblings" || return $?
}

##!
##! Standalone function because of recursive calls.
##! Seems that positional arguments are local and safe to use recursively.
##!
##! @param $1 {identifier} - initialized buffer out variable name
##! @param $2 {number} - snapshot number
##! @param $3 {number} - interface number
##! @param $4 {string} - node id
##! @param $5 {number} - level
##! @param $6 {string} - children
##! @param $7 {string} - parents siblings "bit map"
##!
_render_node_children() {
    for rndchd_child in $6; do
        _render_node "$1" "$2" "$3" "$rndchd_child" "$(($5 + 1))" "$6" "$7" || return $?
    done
}

#
# EXPRESSIONS/CONDITIONS/TEMPLATES
# ==============================================================================

##!
##! @param $1 {identifier} - result out variable name
##! @param $2 {number} - snapshot number
##! @param $3 {number} - interface number
##! @param $4 {string} - node id
##! @param $5 {string} - property
##! @return ERR_RESOLVE_PROP_NOT_FOUND
##!
resolve_property() {
    [ "${1-}" != "" ] || exit_err "resolve_property: empty argument 1"
    [ "${2-}" != "" ] || exit_err "resolve_property: empty argument 2"
    [ "${3-}" != "" ] || exit_err "resolve_property: empty argument 3"
    [ "${4-}" != "" ] || exit_err "resolve_property: empty argument 4"
    [ "${5-}" != "" ] || exit_err "resolve_property: empty argument 5"

    rsvprt_snapshot_num="$2"
    rsvprt_iface_num="$3"
    rsvprt_node_id="$4"
    rsvprt_property="$5"

    rsvprt_namespace=""
    rsvprt_properties=""

    if [ "${rsvprt_property#"interface."}" != "$rsvprt_property" ]; then
        make_interface_namespace "rsvprt_namespace" "$rsvprt_snapshot_num" "$rsvprt_iface_num" || return $?

        get_interface_properties "rsvprt_properties" "$rsvprt_namespace" || 
            return "$ERR_RESOLVE_PROP_NOT_FOUND"
        
        rsvprt_property="${rsvprt_property#"interface."}"
    else
        rsvprt_node_namespace=""
        find_node_namespace_by_id \
            "rsvprt_node_namespace" \
            "$rsvprt_snapshot_num" \
            "$rsvprt_iface_num" \
            "$rsvprt_node_id" || return "$ERR_RESOLVE_PROP_NOT_FOUND"

        [ "$g_debug" != "1" ] || log "Node namespace: $rsvprt_node_namespace"

        if [ "${rsvprt_property#"parent."}" != "$rsvprt_property" ]; then
            # All nodes MUST have property "parent_id". No need to check its existence.
            # Calling `get_node_property` should not fail as well.
            rsvprt_parent_id=""
            get_node_property "rsvprt_parent_id" "$rsvprt_node_namespace" "parent_id" || 
                return "$ERR_RESOLVE_PROP_NOT_FOUND"

            [ "$rsvprt_parent_id" != "" ] || return "$ERR_RESOLVE_PROP_NOT_FOUND"

            find_node_namespace_by_id \
                "rsvprt_namespace" \
                "$rsvprt_snapshot_num" \
                "$rsvprt_iface_num" \
                "$rsvprt_parent_id" || return "$ERR_RESOLVE_PROP_NOT_FOUND"

            get_node_properties "rsvprt_properties" "$rsvprt_namespace" || 
                return "$ERR_RESOLVE_PROP_NOT_FOUND"

            rsvprt_property="${rsvprt_property#"parent."}"
        else
            rsvprt_namespace="$rsvprt_node_namespace"
            get_node_properties "rsvprt_properties" "$rsvprt_node_namespace" || 
                return "$ERR_RESOLVE_PROP_NOT_FOUND"
        fi
    fi

    if [ "${rsvprt_properties#*" $rsvprt_property "}" = "$rsvprt_properties" ]; then
        [ "$g_debug" != "1" ] || log "Property '$rsvprt_property' does not exist"
        return "$ERR_RESOLVE_PROP_NOT_FOUND"
    fi

    rsvprt_real_property="$rsvprt_property"

    case "$rsvprt_property" in
        handle_full)
            rsvprt_real_property="handle"
            ;;
    esac

    rsvprt_prop_variable="${rsvprt_namespace}${rsvprt_real_property}"

    if ! var_exists "$rsvprt_prop_variable"; then
        [ "$g_debug" != "1" ] || log "Variable with name '$rsvprt_prop_variable' does not exist"
        return "$ERR_RESOLVE_PROP_NOT_FOUND"
    fi

    rsvprt_result=""
    var_set_expanded "rsvprt_result" "$rsvprt_prop_variable" || return "$ERR_RESOLVE_PROP_NOT_FOUND"

    [ "$g_debug" != "1" ] || log "Variable exists and its value: $rsvprt_result"

    case "$rsvprt_property" in
        handle)
            rsvprt_node_type=""
            var_set_expanded "rsvprt_node_type" "${rsvprt_node_namespace}type" || 
                return "$ERR_RESOLVE_PROP_NOT_FOUND"

            [ "$g_debug" != "1" ] || log "Node type: $rsvprt_node_type"

            if [ "$rsvprt_node_type" = "qdisc" ]; then
                rsvprt_result="${rsvprt_result%":0"}:"
            elif [ "$rsvprt_node_type" = "class" ] && [ "${rsvprt_result#"0:"}" != "$rsvprt_result" ]; then
                rsvprt_result=":${rsvprt_result#"0:"}"
            fi
            ;;
    esac

    var_set "$1" "$rsvprt_result"
}

##!
##! Snapshots times: 800 700 600 500 400 300 200
##! Collect time: 390
##! Target time: 800 - 390 = 410
##! Result list: 800 700 600 500 400
##!
##! Snapshot time 400 is not in the range 410..800, then why does it go to the result list?
##! This is because the last time in the result list will be the one that is the closest to the target time.
##! In this example 410 is closer to 400 than to 500 this is why it's included.
##! Target times 450..549 are closer to 500, 350..449 - to 400, 250..349 - to 300, and so on.
##!
##! @param $1 {identifier} - result out prefix
##! @param $2 {identifier} - result out points count
##! @param $3 {number} - initial snapshot number
##! @param $4 {number} - interface number
##! @param $5 {string} - node id
##! @param $6 {string} - property
##! @param $7 {number} - time in ms [optional=1000]
##! @param $8 {number} - strict [optional=1]
##! @param $9 {number} - endpoints only [optional=0]
##! @return ERR_NODE_NO_PARENT
##! @return ERR_NODE_NS_BY_ID_NOT_EXISTS
##! @return ERR_RESOLVE_PROP_NOT_FOUND
##!
resolve_property_time_series() {
    [ "${1-}" != "" ] || exit_err "resolve_property_time_series: empty argument 1"
    [ "${2-}" != "" ] || exit_err "resolve_property_time_series: empty argument 2"
    [ "${3-}" != "" ] || exit_err "resolve_property_time_series: empty argument 3"
    [ "${4-}" != "" ] || exit_err "resolve_property_time_series: empty argument 4"
    [ "${5-}" != "" ] || exit_err "resolve_property_time_series: empty argument 5"
    [ "${6-}" != "" ] || exit_err "resolve_property_time_series: empty argument 6"

    rsptms_initial_snapshot_num="$3"
    rsptms_iface_num="$4"
    rsptms_node_id="$5"
    rsptms_req_property="$6"
    rsptms_series_time="${7-1000}"
    rsptms_strict="${8-1}"
    rsptms_endpoints_only="${9-0}"

    [ "$rsptms_initial_snapshot_num" != "0" ] || 
        exit_err "resolve_property_time_series: unexpected snapshot number '0'" # unreachable

    rsptms_filled_snapshot_nums=""
    get_snapshot_numbers_from_newest "rsptms_filled_snapshot_nums" || return $?

    rsptms_initial_time=""
    rsptms_prev_time=""
    rsptms_target_time=""
    rsptms_break_after_adding=""
    rsptms_series_nums=""

    for rsptms_snapshot_num in $rsptms_filled_snapshot_nums; do
        rsptms_interface_namespace=""
        make_interface_namespace \
            "rsptms_interface_namespace" \
            "$rsptms_snapshot_num" \
            "$rsptms_iface_num" || return $?

        # Time must always be set. But it may equal to '0' if `date` is not supported.
        rsptms_time=""
        var_set_expanded "rsptms_time" "${rsptms_interface_namespace}fetch_time" || rsptms_time=0

        var_set "rsptms_snapshot${rsptms_snapshot_num}_time" "$rsptms_time"

        if [ "$rsptms_initial_time" = "" ]; then
            # First snapshot: add to the list and calculate target time
            rsptms_initial_time="$rsptms_time"
            rsptms_series_nums="$rsptms_snapshot_num"
            rsptms_target_time=$((rsptms_initial_time - rsptms_series_time))

            continue
        fi

        if [ "$rsptms_time" -le "$rsptms_target_time" ]; then
            if [ "$rsptms_prev_time" != "" ]; then
                # Third snapshot or older: compare against the previous one
                rsptms_target_time_delta=$((rsptms_target_time - rsptms_time))
                rsptms_target_prev_time_delta=$((rsptms_prev_time - rsptms_target_time))

                # Do not include current snapshot to the result list if its delta greater or equal to the previous one
                [ "$rsptms_target_time_delta" -lt "$rsptms_target_prev_time_delta" ] || break
            fi

            rsptms_break_after_adding="1"
        fi

        rsptms_series_nums="${rsptms_series_nums}${rsptms_series_nums:+" "}${rsptms_snapshot_num}"

        [ "$rsptms_break_after_adding" != "1" ] || break

        rsptms_prev_time="$rsptms_time"
    done

    if [ "$rsptms_endpoints_only" = "1" ] && [ "${rsptms_series_nums#*" "}" != "$rsptms_series_nums" ]; then
        rsptms_last_num="${rsptms_series_nums##*" "}"
        rsptms_series_nums="${rsptms_series_nums%%" "*} $rsptms_last_num"
    fi

    rsptms_series_count=0

    for rsptms_snapshot_num in $rsptms_series_nums; do
        rsptms_series_count=$((rsptms_series_count + 1))

        # Variable is set above. Must not fail.
        var_set_expanded \
            "${1}${rsptms_series_count}_time" \
            "rsptms_snapshot${rsptms_snapshot_num}_time" || return $?

        unset "${1}${rsptms_series_count}_value" || :
        unset "${1}${rsptms_series_count}_not_found" || :

        rsptms_not_found="0"

        rsptms_resolve_status=0
        resolve_property \
            "${1}${rsptms_series_count}_value" \
            "$rsptms_snapshot_num" \
            "$rsptms_iface_num" \
            "$rsptms_node_id" \
            "$rsptms_req_property" || rsptms_resolve_status=$?

        if [ "$rsptms_resolve_status" != "0" ]; then
            if [ "$rsptms_strict" = "1" ]; then
                return "$ERR_RESOLVE_PROP_NOT_FOUND"
            else
                rsptms_not_found="1"
            fi
        fi

        var_set "${1}${rsptms_series_count}_not_found" "$rsptms_not_found"
    done

    var_set "$2" "$rsptms_series_count"
}

##!
##! @param $1 {identifier} - result out variable name
##! @param $2 {number} - snapshot number
##! @param $3 {number} - interface number
##! @param $4 {string} - node id
##! @param $5 {string} - expression
##! @return ERR_EXPR_PROP_NOT_FOUND
##! @return ERR_EXPR_EXPLICIT_PROPERTY_NOT_FOUND
##! @return ERR_EXPR_INSUFFICIENT_DATA
##! @return ERR_EXPR_PROP_INVALID_FORMAT
##! @return ERR_EXPR_TRANSFORMER_FAILED
##!
evaluate_node_expression() {
    [ "${1-}" != "" ] || exit_err "evaluate_node_expression: empty argument 1"
    [ "${2-}" != "" ] || exit_err "evaluate_node_expression: empty argument 2"
    [ "${3-}" != "" ] || exit_err "evaluate_node_expression: empty argument 3"
    [ "${4-}" != "" ] || exit_err "evaluate_node_expression: empty argument 4"
    [ "${5+a}" != "" ] || exit_err "evaluate_node_expression: argument 5 must be specified"

    vlndxp_out_var="$1"
    vlndxp_snapshot_num="$2"
    vlndxp_iface_num="$3"
    vlndxp_node_id="$4"
    vlndxp_expression="$5"

    str_trim "vlndxp_expression" "$vlndxp_expression" || return $?

    if [ "$vlndxp_expression" = "" ]; then
        var_set "$vlndxp_out_var" ""
        return 0
    fi

    vlndxp_is_number="1"

    case "$vlndxp_expression" in
        *[!0-9.]*)
            vlndxp_is_number=""
            ;;
    esac

    if [ "$vlndxp_is_number" = "1" ]; then
        var_set "$vlndxp_out_var" "$vlndxp_expression"
        return 0
    fi

    vlndxp_expr_unquoted=""
    vlndxp_expr_quote=""
    str_unquote "vlndxp_expr_unquoted" "$vlndxp_expression" "vlndxp_expr_quote" || return $?

    if [ "$vlndxp_expr_quote" != "" ]; then
        var_set "$vlndxp_out_var" "$vlndxp_expr_unquoted"
        return 0
    fi

    vlndxp_transformers="${vlndxp_expression#*"|"}"

    if [ "$vlndxp_transformers" != "$vlndxp_expression" ]; then
        vlndxp_expression="${vlndxp_expression%%"|"*}"
    else
        vlndxp_transformers=""
    fi

    vlndxp_result_value=""
    vlndxp_skip_transformers=""

    vlndxp_expr_unquoted=""
    vlndxp_expr_quote=""
    str_unquote "vlndxp_expr_unquoted" "$vlndxp_expression" "vlndxp_expr_quote" || return $?

    if [ "$vlndxp_expr_quote" != "" ]; then
        vlndxp_result_value="$vlndxp_expr_unquoted"
    else
        if [ "${vlndxp_expression#*":"}" != "$vlndxp_expression" ]; then
            vlndxp_expr_fn="${vlndxp_expression%":"*}"
            vlndxp_expr_value="${vlndxp_expression#*":"}"
        else
            vlndxp_expr_fn=""
            vlndxp_expr_value="$vlndxp_expression"
        fi

        vlndxp_is_explicit_prop=""

        if [ "${vlndxp_expr_value%"!"}" != "$vlndxp_expr_value" ]; then
            vlndxp_expr_value="${vlndxp_expr_value%"!"}"
            vlndxp_is_explicit_prop="1"
        fi

        if [ "$vlndxp_expr_fn" = "" ]; then
            vlndxp_resolve_status="0"

            resolve_property \
                "vlndxp_result_value" \
                "$vlndxp_snapshot_num" \
                "$vlndxp_iface_num" \
                "$vlndxp_node_id" \
                "$vlndxp_expr_value" || vlndxp_resolve_status=$?

            if [ "$vlndxp_resolve_status" = "$ERR_RESOLVE_PROP_NOT_FOUND" ]; then
                [ "$vlndxp_is_explicit_prop" != "1" ] || return "$ERR_EXPR_EXPLICIT_PROPERTY_NOT_FOUND"
                return "$ERR_EXPR_PROP_NOT_FOUND"
            elif [ "$vlndxp_resolve_status" != "0" ]; then
                return "$vlndxp_resolve_status"
            fi
        else
            vlndxp_resolve_status="0"

            vlndxp_snap_prop1_value=""
            vlndxp_snap_prop1_time=""
            vlndxp_snap_prop2_value=""
            vlndxp_snap_prop2_time=""
            vlndxp_snap_props_count=0

            # TODO: make it configurable rate(2000):sent_bytes
            vlndxp_series_time=1000

            case "$vlndxp_expr_fn" in
                diff)
                    vlndxp_series_time=1
                    ;;
            esac

            resolve_property_time_series \
                "vlndxp_snap_prop" \
                "vlndxp_snap_props_count" \
                "$vlndxp_snapshot_num" \
                "$vlndxp_iface_num" \
                "$vlndxp_node_id" \
                "$vlndxp_expr_value" \
                "$vlndxp_series_time" \
                1 \
                1 || vlndxp_resolve_status=$?

            if [ "$vlndxp_resolve_status" = "$ERR_RESOLVE_PROP_NOT_FOUND" ]; then
                [ "$vlndxp_is_explicit_prop" != "1" ] || return "$ERR_EXPR_EXPLICIT_PROPERTY_NOT_FOUND"
                return "$ERR_EXPR_PROP_NOT_FOUND"
            elif [ "$vlndxp_resolve_status" != "0" ]; then
                return "$vlndxp_resolve_status"
            elif [ "$vlndxp_snap_props_count" -lt 2 ]; then
                return "$ERR_EXPR_INSUFFICIENT_DATA"
            fi

            case "$vlndxp_expr_fn" in
                rate)
                    [ "${vlndxp_snap_prop1_value-}" != "" ] || return "$ERR_EXPR_INSUFFICIENT_DATA"
                    [ "${vlndxp_snap_prop2_value-}" != "" ] || return "$ERR_EXPR_INSUFFICIENT_DATA"

                    [ "${vlndxp_snap_prop1_time-0}" != "0" ] || return "$ERR_EXPR_INSUFFICIENT_DATA"
                    [ "${vlndxp_snap_prop2_time-0}" != "0" ] || return "$ERR_EXPR_INSUFFICIENT_DATA"

                    for vlndxp_test_val in "$vlndxp_snap_prop1_value" "$vlndxp_snap_prop2_value" \
                        "$vlndxp_snap_prop1_time" "$vlndxp_snap_prop2_time"
                    do
                        case "$vlndxp_test_val" in
                            *[!0-9]*)
                                return "$ERR_EXPR_PROP_INVALID_FORMAT"
                                ;;
                        esac
                    done

                    vlndxp_interval=$((vlndxp_snap_prop1_time - vlndxp_snap_prop2_time))

                    [ "$vlndxp_interval" -gt 0 ] || return "$ERR_EXPR_INSUFFICIENT_DATA"

                    # Must not fail: both operands are integers
                    vlndxp_ratio=""
                    decimal_div "vlndxp_ratio" 1000 "$vlndxp_interval" || return $?

                    vlndxp_value_diff=$((vlndxp_snap_prop1_value - vlndxp_snap_prop2_value))

                    # Must not fail: value_diff is an integer
                    decimal_mul \
                        "vlndxp_result_value" \
                        "$vlndxp_value_diff" \
                        "$vlndxp_ratio" \
                        3 || return $?
                    ;;
                diff)
                    [ "${vlndxp_snap_prop1_value-}" != "" ] || return "$ERR_EXPR_INSUFFICIENT_DATA"
                    [ "${vlndxp_snap_prop2_value-}" != "" ] || return "$ERR_EXPR_INSUFFICIENT_DATA"

                    for vlndxp_test_val in "$vlndxp_snap_prop1_value" "$vlndxp_snap_prop2_value"; do
                        case "$vlndxp_test_val" in
                            *[!0-9]*)
                                return "$ERR_EXPR_PROP_INVALID_FORMAT"
                                ;;
                        esac
                    done

                    if [ "$vlndxp_snap_prop1_value" -gt "$vlndxp_snap_prop2_value" ]; then
                        vlndxp_result_value=$((vlndxp_snap_prop1_value - vlndxp_snap_prop2_value))
                    elif [ "$vlndxp_snap_prop1_value" -lt "$vlndxp_snap_prop2_value" ]; then
                        vlndxp_result_value="-$((vlndxp_snap_prop2_value - vlndxp_snap_prop1_value))"
                    else
                        vlndxp_result_value="0"
                    fi
                    ;;
            esac
        fi
    fi

    if [ "$vlndxp_skip_transformers" != "1" ] && [ "$vlndxp_transformers" != "" ]; then
        run_node_transformers \
            "vlndxp_result_value" \
            "$vlndxp_snapshot_num" \
            "$vlndxp_iface_num" \
            "$vlndxp_node_id" \
            "$vlndxp_transformers" \
            "$vlndxp_result_value" || return "$ERR_EXPR_TRANSFORMER_FAILED"
    fi

    var_set "$vlndxp_out_var" "$vlndxp_result_value"
}

##!
##! @param $1 {identifier} - result out variable name
##! @param $2 {number} - snapshot number
##! @param $3 {number} - interface number
##! @param $4 {string} - node id
##! @param $5 {string} - transformers string
##! @param $6 {string} - initial value
##!
run_node_transformers() {
    [ "${1-}" != "" ] || exit_err "run_node_transformers: empty argument 1"
    [ "${2-}" != "" ] || exit_err "run_node_transformers: empty argument 2"
    [ "${3-}" != "" ] || exit_err "run_node_transformers: empty argument 3"
    [ "${4-}" != "" ] || exit_err "run_node_transformers: empty argument 4"
    [ "${5-}" != "" ] || exit_err "run_node_transformers: empty argument 5"
    [ "${6+a}" != "" ] || exit_err "run_node_transformers: argument 6 must be specified"

    rndtrfm_transformers="$5"
    rndtrfm_result_value="$6"

    rndtrfm_transformers_orig="$rndtrfm_transformers"

    rndtrfm_transformers_prev=""

    while [ "$rndtrfm_transformers" != "" ] && 
        [ "$rndtrfm_transformers" != "$rndtrfm_transformers_prev" ]
    do
        rndtrfm_transformers_prev="$rndtrfm_transformers"

        rndtrfm_transformer="${rndtrfm_transformers%%"|"*}"

        if [ "$rndtrfm_transformer" != "$rndtrfm_transformers" ]; then
            rndtrfm_transformers="${rndtrfm_transformers#*"|"}"
        else
            rndtrfm_transformers=""
        fi

        str_trim "rndtrfm_transformer" "$rndtrfm_transformer" || return $?

        # Declare some arguments to supress "unassigned" warnings.
        # Always use "count" value to check if the required argument is set.

        # shellcheck disable=SC2034 # appears unused.
        rndtrfm_transformer_arg1=""
        # shellcheck disable=SC2034 # appears unused.
        rndtrfm_transformer_arg2=""
        # shellcheck disable=SC2034 # appears unused.
        rndtrfm_transformer_arg3=""
        # shellcheck disable=SC2034 # appears unused.
        rndtrfm_transformer_arg4=""
        # shellcheck disable=SC2034 # appears unused.
        rndtrfm_transformer_arg5=""

        rndtrfm_transformer_args_count=0
        parse_parentheses_args \
            "rndtrfm_transformer_arg" \
            "rndtrfm_transformer_args_count" \
            "$rndtrfm_transformer" \
            "1" || exit_err "run_node_transformers: transformer args cannot be parsed: $rndtrfm_transformer"

        if [ "$rndtrfm_transformer_args_count" = "0" ]; then
            rndtrfm_transformer="${rndtrfm_transformer%"()"}"
        else
            rndtrfm_transformer="${rndtrfm_transformer%%"("*}"
        fi

        case "$rndtrfm_transformer" in
            len | length)
                rndtrfm_result_value="${#rndtrfm_result_value}"
                ;;
            maxlen | maxlength)
                [ "$rndtrfm_transformer_args_count" -gt 0 ] ||
                    exit_err "run_node_transformers: transformer '$rndtrfm_transformer' requires max length parameter in: $rndtrfm_transformers_orig"

                if [ "${#rndtrfm_result_value}" -gt "$rndtrfm_transformer_arg1" ]; then
                    if [ "$rndtrfm_transformer_args_count" -ge 2 ]; then
                        rndtrfm_strpad="$rndtrfm_transformer_arg2"

                        str_substring \
                            "rndtrfm_result_value" \
                            "$rndtrfm_result_value" \
                            0 \
                            $((rndtrfm_transformer_arg1 - ${#rndtrfm_strpad})) || return $?

                        [ "${rndtrfm_result_value%" "}" = "$rndtrfm_result_value" ] ||
                            str_trim_end "rndtrfm_result_value" "$rndtrfm_result_value" || return $?

                        rndtrfm_result_value="${rndtrfm_result_value}${rndtrfm_strpad}"
                    else
                        str_substring \
                            "rndtrfm_result_value" \
                            "$rndtrfm_result_value" \
                            0 \
                            "$rndtrfm_transformer_arg1" || return $?
                    fi
                fi
                ;;
            repeat | str_repeat)
                [ "$rndtrfm_transformer_args_count" -gt 0 ] ||
                    exit_err "run_node_transformers: transformer '$rndtrfm_transformer' requires times parameter in: $rndtrfm_transformers_orig"

                str_repeat "rndtrfm_result_value" "$rndtrfm_result_value" "$rndtrfm_transformer_arg1" || return $?
                ;;
            trim | trim_left | left_trim | trim_start | trim_right | right_trim | trim_end)
                if [ "$rndtrfm_transformer" = "trim" ]; then
                    str_trim "rndtrfm_result_value" "$rndtrfm_result_value" || return $?
                elif [ "$rndtrfm_transformer" = "trim_right" ] ||
                    [ "$rndtrfm_transformer" = "right_trim" ] ||
                    [ "$rndtrfm_transformer" = "trim_end" ]; then
                    str_trim_end "rndtrfm_result_value" "$rndtrfm_result_value" || return $?
                else
                    str_trim_start "rndtrfm_result_value" "$rndtrfm_result_value" || return $?
                fi
                ;;
            pad_left | left_pad | pad_start | pad_right | right_pad | pad_end)
                [ "$rndtrfm_transformer_args_count" -gt 0 ] ||
                    exit_err "run_node_transformers: transformer '$rndtrfm_transformer' requires pad length parameter in: $rndtrfm_transformers_orig"

                rndtrfm_pad_side="start"
                if [ "$rndtrfm_transformer" = "pad_right" ] ||
                    [ "$rndtrfm_transformer" = "right_pad" ] ||
                    [ "$rndtrfm_transformer" = "pad_end" ]; then
                    rndtrfm_pad_side="end"
                fi

                rndtrfm_pad_str=" "
                [ "$rndtrfm_transformer_args_count" -lt 2 ] || rndtrfm_pad_str="$rndtrfm_transformer_arg2"

                str_pad \
                    "rndtrfm_result_value" \
                    "$rndtrfm_pad_side" \
                    "$rndtrfm_result_value" \
                    "$rndtrfm_transformer_arg1" \
                    "$rndtrfm_pad_str" || return $?
                ;;
            cut_left | left_cut | cut_start | cut_right | right_cut | cut_end)
                [ "$rndtrfm_transformer_args_count" -gt 0 ] ||
                    exit_err "run_node_transformers: transformer '$rndtrfm_transformer' requires cut length parameter in: $rndtrfm_transformers_orig"

                rndtrfm_str_len="${#rndtrfm_result_value}"

                if [ "$rndtrfm_transformer" = "cut_right" ] ||
                    [ "$rndtrfm_transformer" = "right_cut" ] ||
                    [ "$rndtrfm_transformer" = "cut_end" ]; then
                    rndtrfm_start_index="0"
                    rndtrfm_end_index=$((rndtrfm_str_len - rndtrfm_transformer_arg1))
                else
                    rndtrfm_start_index="$rndtrfm_transformer_arg1"
                    rndtrfm_end_index="$rndtrfm_str_len"
                fi

                str_substring \
                    "rndtrfm_result_value" \
                    "$rndtrfm_result_value" \
                    "$rndtrfm_start_index" \
                    "$rndtrfm_end_index" || return $?
                ;;
            oneline)
                if [ "$g_term_columns" != "" ]; then
                    rndtrfm_indent_len=0
                    [ "$rndtrfm_transformer_args_count" -lt 1 ] || rndtrfm_indent_len="$rndtrfm_transformer_arg1"

                    rndtrfm_strpad=""
                    [ "$rndtrfm_transformer_args_count" -lt 2 ] || rndtrfm_strpad="$rndtrfm_transformer_arg2"

                    rndtrfm_strlen="${#rndtrfm_result_value}"

                    if [ "$((rndtrfm_strlen + rndtrfm_indent_len))" -gt "$g_term_columns" ]; then
                        str_substring \
                            "rndtrfm_result_value" \
                            "$rndtrfm_result_value" \
                            0 \
                            $((g_term_columns - rndtrfm_indent_len - ${#rndtrfm_strpad})) || return $?

                        rndtrfm_result_value="${rndtrfm_result_value}${rndtrfm_strpad}"
                    fi
                fi
                ;;
            mul | muldec | decmul)
                [ "$rndtrfm_transformer_args_count" -gt 0 ] ||
                    exit_err "run_node_transformers: transformer '$rndtrfm_transformer' requires multiplier parameter in: $rndtrfm_transformers_orig"

                rndtrfm_trns_multiplier="$rndtrfm_transformer_arg1"

                rndtrfm_trns_precision=0
                if [ "$rndtrfm_transformer" = "muldec" ] || [ "$rndtrfm_transformer" = "decmul" ]; then
                    if [ "$rndtrfm_transformer_args_count" -ge 2 ]; then
                        rndtrfm_trns_precision="$rndtrfm_transformer_arg2"
                    fi
                fi

                decimal_mul \
                    "rndtrfm_result_value" \
                    "$rndtrfm_result_value" \
                    "$rndtrfm_trns_multiplier" \
                    "$rndtrfm_trns_precision" || return $?
                ;;
            floor)
                rndtrfm_trns_precision=0
                [ "$rndtrfm_transformer_args_count" -lt 1 ] || 
                    rndtrfm_trns_precision="$rndtrfm_transformer_arg1"

                number_floor \
                    "rndtrfm_result_value" \
                    "$rndtrfm_result_value" \
                    "$rndtrfm_trns_precision" || return $?
                ;;
            traffic)
                pretty_traffic1024 \
                    "rndtrfm_result_value" \
                    "$rndtrfm_result_value" || return $?
                ;;
            traffic_rate)
                # bits per second
                pretty_div \
                    "rndtrfm_result_value" \
                    "$rndtrfm_result_value" \
                    1000 \
                    "bit kbit mbit gbit" 1 || return $?
                ;;
            traffic_rate_bps)
                # bytes per second
                pretty_div \
                    "rndtrfm_result_value" \
                    "$rndtrfm_result_value" \
                    1000 \
                    "bps kbps mbps gbps" 1 || return $?
                ;;
            *)
                exit_err "run_node_transformers: unknown transformer '$rndtrfm_transformer' in: $rndtrfm_transformers_orig"
                ;;
        esac
    done

    var_set "$1" "$rndtrfm_result_value"
}

##!
##! @param $1 {identifier} - result out variable name
##! @param $2 {number} - snapshot number
##! @param $3 {number} - interface number
##! @param $4 {string} - node id
##! @param $5 {string} - single clause (i.e. ampersand-free)
##!
evaluate_node_condition_clause() {
    [ "${1-}" != "" ] || exit_err "evaluate_node_condition_clause: empty argument 1"
    [ "${2-}" != "" ] || exit_err "evaluate_node_condition_clause: empty argument 2"
    [ "${3-}" != "" ] || exit_err "evaluate_node_condition_clause: empty argument 3"
    [ "${4-}" != "" ] || exit_err "evaluate_node_condition_clause: empty argument 4"
    [ "${5-}" != "" ] || exit_err "evaluate_node_condition_clause: empty argument 5"

    vlndsnt_snapshot_num="$2"
    vlndsnt_iface_num="$3"
    vlndsnt_node_id="$4"
    vlndsnt_cond="$5"

    vlndsnt_cond_orig="$vlndsnt_cond"

    vlndsnt_op_family=""
    vlndsnt_op_subfamily=""
    vlndsnt_operands_count=2

    if [ "${vlndsnt_cond%"="*}" != "$vlndsnt_cond" ]; then
        vlndsnt_op_family="compare"

        if [ "${vlndsnt_cond%"<="*}" != "$vlndsnt_cond" ]; then
            vlndsnt_cond_op="<="
            vlndsnt_op_subfamily="compare_number"
        elif [ "${vlndsnt_cond%">="*}" != "$vlndsnt_cond" ]; then
            vlndsnt_cond_op=">="
            vlndsnt_op_subfamily="compare_number"
        elif [ "${vlndsnt_cond%"!="*}" != "$vlndsnt_cond" ]; then
            vlndsnt_cond_op="!="
        else
            vlndsnt_cond_op="="
        fi

        vlndsnt_operand1="${vlndsnt_cond%"$vlndsnt_cond_op"*}"
        vlndsnt_operand1="${vlndsnt_operand1%"="}" # strip extra equals-sign if exists

        vlndsnt_operand2="${vlndsnt_cond##*"$vlndsnt_cond_op"}"
        vlndsnt_operand2="${vlndsnt_operand2#"="}" # strip extra equals-sign if exists
    elif [ "${vlndsnt_cond%"<"*}" != "$vlndsnt_cond" ]; then
        vlndsnt_op_family="compare"
        vlndsnt_op_subfamily="compare_number"

        vlndsnt_cond_op="<"

        vlndsnt_operand1="${vlndsnt_cond%"$vlndsnt_cond_op"*}"
        vlndsnt_operand2="${vlndsnt_cond##*"$vlndsnt_cond_op"}"
    elif [ "${vlndsnt_cond%">"*}" != "$vlndsnt_cond" ]; then
        vlndsnt_op_family="compare"
        vlndsnt_op_subfamily="compare_number"

        vlndsnt_cond_op=">"

        vlndsnt_operand1="${vlndsnt_cond%"$vlndsnt_cond_op"*}"
        vlndsnt_operand2="${vlndsnt_cond##*"$vlndsnt_cond_op"}"
    else
        vlndsnt_operands_count=1

        str_trim "vlndsnt_cond" "$vlndsnt_cond" " " || return $?

        if [ "${vlndsnt_cond#"!"}" != "$vlndsnt_cond" ]; then
            vlndsnt_cond_op="not_exists"
            vlndsnt_op_family="exists"
            vlndsnt_operand1="${vlndsnt_cond#"!"}"
        else
            vlndsnt_cond_op="exists"
            vlndsnt_op_family="exists"
            vlndsnt_operand1="$vlndsnt_cond"
        fi
    fi

    [ "$g_debug" != "1" ] || log "Condition op: $vlndsnt_cond_op"

    vlndsnt_operand1_val=""
    # shellcheck disable=SC2034 # appears unused
    vlndsnt_operand1_evaled=""

    vlndsnt_operand2_val=""
    # shellcheck disable=SC2034 # appears unused
    vlndsnt_operand2_evaled=""

    vlndsnt_operand_num=0

    while [ "$vlndsnt_operand_num" -lt "$vlndsnt_operands_count" ]; do
        vlndsnt_operand_num=$((vlndsnt_operand_num + 1))

        # Must not fail: operands should exist up to operands_count
        vlndsnt_operand=""
        var_set_expanded "vlndsnt_operand" "vlndsnt_operand${vlndsnt_operand_num}" || return $?

        str_trim "vlndsnt_operand" "$vlndsnt_operand" " " || return $?

        [ "$g_debug" != "1" ] || log "Condition operand${vlndsnt_operand_num}: $vlndsnt_operand"

        [ "$vlndsnt_operand" != "" ] ||
            exit_err "evaluate_node_condition_clause: operand identifier is an empty string"

        vlndsnt_operand_var_value=""
        # shellcheck disable=SC2034 # appears unused
        vlndsnt_operand_expr_status="0"

        # Expression evaluator is aware of numbers and quoted strings
        evaluate_node_expression \
            "vlndsnt_operand_var_value" \
            "$vlndsnt_snapshot_num" \
            "$vlndsnt_iface_num" \
            "$vlndsnt_node_id" \
            "$vlndsnt_operand" || vlndsnt_operand_expr_status=$?

        case "$vlndsnt_operand_expr_status" in
            "0")
                # success, do nothing
                ;;
            "$ERR_EXPR_EXPLICIT_PROPERTY_NOT_FOUND")
                exit_err "evaluate_node_condition_clause: explicit property '$vlndsnt_operand' does not exist. Used in condition: $vlndsnt_cond_orig"
                ;;
            "$ERR_EXPR_PROP_NOT_FOUND" | "$ERR_EXPR_INSUFFICIENT_DATA" | "$ERR_EXPR_PROP_INVALID_FORMAT" | "$ERR_EXPR_TRANSFORMER_FAILED")
                var_set "$1" "0"
                return 0
                ;;
            *)
                return "$vlndsnt_operand_expr_status"
                ;;
        esac

        var_set "vlndsnt_operand${vlndsnt_operand_num}_val" "$vlndsnt_operand_var_value"
        var_set "vlndsnt_operand${vlndsnt_operand_num}_evaled" "1"

        [ "$g_debug" != "1" ] || log "Operand${vlndsnt_operand_num} final value: $vlndsnt_operand_var_value"
    done

    if [ "$vlndsnt_op_family" = "exists" ]; then
        vlndsnt_result="0"

        if [ "$vlndsnt_operand1_evaled" = "1" ]; then
            if [ "$vlndsnt_cond_op" = "exists" ]; then
                vlndsnt_result="1"
            fi
        else
            if [ "$vlndsnt_cond_op" = "not_exists" ]; then
                vlndsnt_result="1"
            fi
        fi

        var_set "$1" "$vlndsnt_result"
        return 0
    fi

    [ "$vlndsnt_operands_count" = "2" ] ||
        exit_err "Operation '$vlndsnt_cond_op' expects 2 operands. Found: $vlndsnt_operands_count"

    if [ "$vlndsnt_op_subfamily" = "compare_number" ]; then
        vlndsnt_compare_result=""
        vlndsnt_compare_status="0"
        number_compare \
            "vlndsnt_compare_result" \
            "$vlndsnt_operand1_val" \
            "$vlndsnt_operand2_val" || vlndsnt_compare_status=$?

        if [ "$vlndsnt_compare_status" = "$ERR_NUMBER_INVALID" ]; then
            var_set "$1" "0"
            return 0
        elif [ "$vlndsnt_compare_status" != "0" ]; then
            return "$vlndsnt_compare_status"
        fi

        vlndsnt_result="0"

        if [ "$vlndsnt_compare_result" = "1" ]; then
            if [ "$vlndsnt_cond_op" = ">" ] || [ "$vlndsnt_cond_op" = ">=" ]; then
                vlndsnt_result="1"
            fi
        elif [ "$vlndsnt_compare_result" = "-1" ]; then
            if [ "$vlndsnt_cond_op" = "<" ] || [ "$vlndsnt_cond_op" = "<=" ]; then
                vlndsnt_result="1"
            fi
        elif [ "$vlndsnt_cond_op" = "<=" ] || [ "$vlndsnt_cond_op" = ">=" ]; then
            # Operands are equal here
            vlndsnt_result="1"
        fi

        var_set "$1" "$vlndsnt_result"
        return 0
    fi

    vlndsnt_result="1"

    case "$vlndsnt_cond_op" in
        "=")
            [ "$vlndsnt_operand1_val" = "$vlndsnt_operand2_val" ] || vlndsnt_result="0"
            ;;
        "!=")
            [ "$vlndsnt_operand1_val" != "$vlndsnt_operand2_val" ] || vlndsnt_result="0"
            ;;
        *)
            exit_err "Unknown operation: $vlndsnt_cond_op"
            ;;
    esac

    var_set "$1" "$vlndsnt_result"
}

##!
##! @param $1 {identifier} - result out variable name
##! @param $2 {number} - snapshot number
##! @param $3 {number} - interface number
##! @param $4 {string} - node id
##! @param $5 {string} - any condition
##!
evaluate_node_condition() {
    [ "${1-}" != "" ] || exit_err "evaluate_node_condition: empty argument 1"
    [ "${2-}" != "" ] || exit_err "evaluate_node_condition: empty argument 2"
    [ "${3-}" != "" ] || exit_err "evaluate_node_condition: empty argument 3"
    [ "${4-}" != "" ] || exit_err "evaluate_node_condition: empty argument 4"
    [ "${5-}" != "" ] || exit_err "evaluate_node_condition: empty argument 5"

    vlndtn_snapshot_num="$2"
    vlndtn_iface_num="$3"
    vlndtn_node_id="$4"
    vlndtn_full_cond="$5"

    [ "$g_debug" != "1" ] || log "Evaluating condition: $vlndtn_full_cond"

    vlndtn_result="1"
    vlndtn_full_cond_prev=""
    vlndtn_cond_clause_idx=0

    while [ "$vlndtn_full_cond" != "" ] && [ "$vlndtn_full_cond" != "$vlndtn_full_cond_prev" ]; do
        vlndtn_full_cond_prev="$vlndtn_full_cond"
        vlndtn_cond_clause_idx=$((vlndtn_cond_clause_idx + 1))

        vlndtn_cond_clause="${vlndtn_full_cond%%"&"*}"

        if [ "$vlndtn_cond_clause" != "$vlndtn_full_cond" ]; then
            vlndtn_full_cond="${vlndtn_full_cond#*"&"}"
            # Operators`&` and `&&` are identical, trim second "&" if double `&&` was used
            vlndtn_full_cond="${vlndtn_full_cond#"&"}"
        else
            vlndtn_full_cond=""
        fi

        [ "$g_debug" != "1" ] || log "Clause $vlndtn_cond_clause_idx: $vlndtn_cond_clause"
        [ "$g_debug" != "1" ] || log "Remaining condition: $vlndtn_full_cond"

        vlndtn_matched=""
        evaluate_node_condition_clause \
            "vlndtn_matched" \
            "$vlndtn_snapshot_num" \
            "$vlndtn_iface_num" \
            "$vlndtn_node_id" \
            "$vlndtn_cond_clause" || return $?

        [ "$g_debug" != "1" ] || log "Result of evaluating the clause: '$vlndtn_matched'"

        if [ "$vlndtn_matched" = "0" ]; then
            [ "$g_debug" != "1" ] || log "Node does not match the condition"

            vlndtn_result="0"
            break
        fi

        [ "$vlndtn_matched" = "1" ] ||
            exit_err "evaluate_node_condition: unexpected result of evaluating condition clause '$vlndtn_matched'"
    done

    var_set "$1" "$vlndtn_result"
}

##!
##! @param $1 {identifier} - result out variable name
##! @param $2 {number} - snapshot number
##! @param $3 {number} - interface number
##! @param $4 {string} - node id
##! @param $5 {string} - template
##! @param $6 {number} - indent length in characters [optional=0]
##!
render_node_template() {
    [ "${1-}" != "" ] || exit_err "render_node_template: empty argument 1"
    [ "${2-}" != "" ] || exit_err "render_node_template: empty argument 2"
    [ "${3-}" != "" ] || exit_err "render_node_template: empty argument 3"
    [ "${4-}" != "" ] || exit_err "render_node_template: empty argument 4"
    [ "${5+a}" != "" ] || exit_err "render_node_template: argument 5 must be specified"

    rndtmt_snapshot_num="$2"
    rndtmt_iface_num="$3"
    rndtmt_node_id="$4"
    rndtmt_template="$5"
    rndtmt_line_indent_len="${6-0}"

    rndtmt_template_orig="$rndtmt_template"

    #
    # Conditions:
    #   [% if diff:dropped > 0 %]there are some drops[% else %]no drops[% endif %]
    #

    rndtmt_cond_evaled=""
    rndtmt_template_prev=""

    while [ "$rndtmt_template" != "" ] && [ "$rndtmt_template" != "$rndtmt_template_prev" ]; do
        rndtmt_template_prev="$rndtmt_template"

        rndtmt_non_cond="${rndtmt_template%%"[%"*}"

        if [ "$rndtmt_non_cond" != "" ]; then
            rndtmt_cond_evaled="${rndtmt_cond_evaled}${rndtmt_non_cond}"
        fi

        if [ "$rndtmt_non_cond" = "$rndtmt_template" ]; then
            # No "[%" was found.
            rndtmt_template=""
            break
        fi

        rndtmt_remaining="${rndtmt_template#"${rndtmt_non_cond}[%"}"

        [ "$rndtmt_remaining" != "$rndtmt_template" ] ||
            exit_err "render_node_template: unexpected remaining part '$rndtmt_remaining' in template: $rndtmt_template_orig"

        rndtmt_template="$rndtmt_remaining"

        rndtmt_template_left_trimmed=""
        str_trim_start "rndtmt_template_left_trimmed" "$rndtmt_template" || return $?

        rndtmt_stripped_if="${rndtmt_template_left_trimmed#"if "}"

        if [ "$rndtmt_stripped_if" != "$rndtmt_template_left_trimmed" ]; then
            # "if" keyword found
            rndtmt_template="$rndtmt_stripped_if"

            rndtmt_cond_raw="${rndtmt_template%%"%]"*}"

            [ "$rndtmt_cond_raw" != "$rndtmt_template" ] ||
                exit_err "render_node_template: unclosed 'if' clause found in template: $rndtmt_template_orig"

            rndtmt_remaining="${rndtmt_template#"${rndtmt_cond_raw}%]"}"

            [ "$rndtmt_remaining" != "$rndtmt_template" ] ||
                exit_err "render_node_template: unexpected remaining part '$rndtmt_remaining' in template: $rndtmt_template_orig"

            rndtmt_template="$rndtmt_remaining"

            rndtmt_cond_trimmed=""
            str_trim "rndtmt_cond_trimmed" "$rndtmt_cond_raw" || return $?

            rndtmt_true_payload="${rndtmt_template%%"[%"*}"

            [ "$rndtmt_true_payload" != "$rndtmt_template" ] ||
                exit_err "render_node_template: 'endif' part not found in template: $rndtmt_template_orig"

            rndtmt_remaining="${rndtmt_template#"${rndtmt_true_payload}[%"}"

            [ "$rndtmt_remaining" != "$rndtmt_template" ] ||
                exit_err "render_node_template: unexpected remaining part '$rndtmt_remaining' in template: $rndtmt_template_orig"

            rndtmt_template="$rndtmt_remaining"

            rndtmt_next_keyword_raw="${rndtmt_template%%"%]"*}"

            [ "$rndtmt_next_keyword_raw" != "$rndtmt_template" ] ||
                exit_err "render_node_template: unclosed 'if' clause found in template: $rndtmt_template_orig"

            rndtmt_remaining="${rndtmt_template#"${rndtmt_next_keyword_raw}%]"}"

            [ "$rndtmt_remaining" != "$rndtmt_template" ] ||
                exit_err "render_node_template: unexpected remaining part '$rndtmt_remaining' in template: $rndtmt_template_orig"

            rndtmt_template="$rndtmt_remaining"

            rndtmt_next_keyword_trimmed=""
            str_trim "rndtmt_next_keyword_trimmed" "$rndtmt_next_keyword_raw" || return $?

            rndtmt_else_part_exists=""

            if [ "$rndtmt_next_keyword_trimmed" = "else" ]; then
                rndtmt_else_part_exists="1"

                rndtmt_false_payload="${rndtmt_template%%"[%"*}"

                [ "$rndtmt_false_payload" != "$rndtmt_template" ] ||
                    exit_err "render_node_template: 'endif' part not found in template: $rndtmt_template_orig"

                rndtmt_remaining="${rndtmt_template#"${rndtmt_false_payload}[%"}"

                [ "$rndtmt_remaining" != "$rndtmt_template" ] ||
                    exit_err "render_node_template: unexpected remaining part '$rndtmt_remaining' in template: $rndtmt_template_orig"

                rndtmt_template="$rndtmt_remaining"

                rndtmt_next_keyword_raw="${rndtmt_template%%"%]"*}"

                [ "$rndtmt_next_keyword_raw" != "$rndtmt_template" ] ||
                    exit_err "render_node_template: unclosed 'if' clause found in template: $rndtmt_template_orig"

                rndtmt_remaining="${rndtmt_template#"${rndtmt_next_keyword_raw}%]"}"

                [ "$rndtmt_remaining" != "$rndtmt_template" ] ||
                    exit_err "render_node_template: unexpected remaining part '$rndtmt_remaining' in template: $rndtmt_template_orig"

                rndtmt_template="$rndtmt_remaining"

                rndtmt_next_keyword_trimmed=""
                str_trim "rndtmt_next_keyword_trimmed" "$rndtmt_next_keyword_raw" || return $?
            fi

            [ "$rndtmt_next_keyword_trimmed" = "endif" ] ||
                exit_err "render_node_template: 'endif' expected, but found '$rndtmt_next_keyword_trimmed' in template: $rndtmt_template_orig"

            rndtmt_matched=""
            evaluate_node_condition \
                "rndtmt_matched" \
                "$rndtmt_snapshot_num" \
                "$rndtmt_iface_num" \
                "$rndtmt_node_id" \
                "$rndtmt_cond_trimmed" || rndtmt_matched=0

            if [ "$rndtmt_matched" = "1" ]; then
                rndtmt_cond_evaled="${rndtmt_cond_evaled}${rndtmt_true_payload}"
            elif [ "$rndtmt_else_part_exists" = "1" ]; then
                rndtmt_cond_evaled="${rndtmt_cond_evaled}${rndtmt_false_payload}"
            else
                rndtmt_cond_evaled="${rndtmt_cond_evaled}{}"
            fi
        else
            # This was not "if" keyword. Then just add raw "[%" to the buffer and continue evaluating
            rndtmt_cond_evaled="${rndtmt_cond_evaled}[%"
        fi
    done

    #
    # Expressions:
    #   {rate:sent_bytes|traffic_rate|pad_start(15)}
    #

    rndtmt_expr_evaled=""
    rndtmt_expr_evaled_line=""
    rndtmt_cond_evaled_prev=""

    while [ "$rndtmt_cond_evaled" != "" ] && [ "$rndtmt_cond_evaled" != "$rndtmt_cond_evaled_prev" ]; do
        rndtmt_cond_evaled_prev="$rndtmt_cond_evaled"

        rndtmt_plain="${rndtmt_cond_evaled%%"{"*}"

        if [ "$rndtmt_plain" != "" ]; then
            rndtmt_expr_evaled_line="${rndtmt_expr_evaled_line}${rndtmt_plain}"
        fi

        if [ "$rndtmt_plain" = "$rndtmt_cond_evaled" ]; then
            # No "{" was found
            break
        fi

        rndtmt_remaining="${rndtmt_cond_evaled#"${rndtmt_plain}{"}"

        [ "$rndtmt_remaining" != "$rndtmt_cond_evaled" ] ||
            exit_err "render_node_template: unexpected remaining part '$rndtmt_remaining' in template: $rndtmt_template_orig"

        rndtmt_cond_evaled="$rndtmt_remaining"

        rndtmt_expr_raw="${rndtmt_cond_evaled%%"}"*}"

        [ "$rndtmt_expr_raw" != "$rndtmt_cond_evaled" ] ||
            exit_err "render_node_template: unclosed expression near '$rndtmt_cond_evaled' in template: $rndtmt_template_orig"

        rndtmt_remaining="${rndtmt_cond_evaled#"${rndtmt_expr_raw}}"}"

        [ "$rndtmt_remaining" != "$rndtmt_cond_evaled" ] ||
            exit_err "render_node_template: unexpected remaining part '$rndtmt_remaining' in template: $rndtmt_template_orig"

        rndtmt_cond_evaled="$rndtmt_remaining"

        rndtmt_text=""

        case "$rndtmt_expr_raw" in
            "")
                rndtmt_text=""
                ;;
            __indent_length)
                rndtmt_text="$rndtmt_line_indent_len"
                ;;
            nl | nl!)
                str_trim_end "rndtmt_expr_evaled_line" "$rndtmt_expr_evaled_line" || return $?

                if [ "$rndtmt_expr_evaled_line" != "" ]; then
                    rndtmt_expr_evaled="${rndtmt_expr_evaled}${rndtmt_expr_evaled_line}$TCTREE_NL"
                else
                    rndtmt_expr_evaled="${rndtmt_expr_evaled%"$TCTREE_NL"}$TCTREE_NL"
                fi

                rndtmt_expr_evaled_line=""

                continue
                ;;
            *)
                rndtmt_expr_status="0"
                evaluate_node_expression \
                    "rndtmt_text" \
                    "$rndtmt_snapshot_num" \
                    "$rndtmt_iface_num" \
                    "$rndtmt_node_id" \
                    "$rndtmt_expr_raw" || rndtmt_expr_status=$?

                case "$rndtmt_expr_status" in
                    "0")
                        # success, do nothing
                        ;;
                    "$ERR_EXPR_EXPLICIT_PROPERTY_NOT_FOUND")
                        exit_err "render_node_template: variable '$rndtmt_expr_raw' not found in template: $rndtmt_template_orig"
                        ;;
                    "$ERR_EXPR_PROP_NOT_FOUND" | "$ERR_EXPR_PROP_INVALID_FORMAT" | "$ERR_EXPR_TRANSFORMER_FAILED")
                        rndtmt_text=""
                        ;;
                    "$ERR_EXPR_INSUFFICIENT_DATA")
                        rndtmt_text="n/a"
                        ;;
                    *)
                        return "$rndtmt_expr_status"
                        ;;
                esac
                ;;
        esac

        rndtmt_expr_evaled_line="${rndtmt_expr_evaled_line}${rndtmt_text}"
    done

    if [ "$rndtmt_expr_evaled_line" != "" ]; then
        rndtmt_expr_evaled="${rndtmt_expr_evaled}${rndtmt_expr_evaled_line}"
    fi

    #
    # Blocks:
    #   [[[{type} {handle} {kind}]|maxlen(30)|cut_right({_indent_length})]]
    #

    rndtmt_block_evaled=""
    rndtmt_expr_evaled_prev=""

    while [ "$rndtmt_expr_evaled" != "" ] && [ "$rndtmt_expr_evaled" != "$rndtmt_expr_evaled_prev" ]; do
        rndtmt_expr_evaled_prev="$rndtmt_expr_evaled"

        rndtmt_plain="${rndtmt_expr_evaled%%"[[["*}"

        if [ "$rndtmt_plain" != "" ]; then
            rndtmt_block_evaled="${rndtmt_block_evaled}${rndtmt_plain}"
        fi

        if [ "$rndtmt_plain" = "$rndtmt_expr_evaled" ]; then
            # No "[[[" was found
            break
        fi

        rndtmt_remaining="${rndtmt_expr_evaled#"${rndtmt_plain}[[["}"

        [ "$rndtmt_remaining" != "$rndtmt_expr_evaled" ] ||
            exit_err "render_node_template: unexpected remaining part '$rndtmt_remaining' in template: $rndtmt_template_orig"

        rndtmt_expr_evaled="$rndtmt_remaining"

        rndtmt_block_buffer=""
        rndtmt_block_text=""
        rndtmt_block_transformers=""

        while :; do
            rndtmt_block_part="${rndtmt_expr_evaled%%"]]"*}"

            rndtmt_block_buffer="${rndtmt_block_buffer}${rndtmt_block_part}"

            [ "$rndtmt_block_part" != "$rndtmt_expr_evaled" ] ||
                exit_err "render_node_template: unclosed block near '$rndtmt_expr_evaled' in template: $rndtmt_template_orig"

            rndtmt_remaining="${rndtmt_expr_evaled#"${rndtmt_block_part}]]"}"

            [ "$rndtmt_remaining" != "$rndtmt_expr_evaled" ] ||
                exit_err "render_node_template: unexpected remaining part '$rndtmt_remaining' in template: $rndtmt_template_orig"

            rndtmt_expr_evaled="$rndtmt_remaining"

            if [ "${rndtmt_block_buffer%"]|"*}" != "$rndtmt_block_buffer" ]; then
                rndtmt_block_text="${rndtmt_block_buffer%"]|"*}"
                rndtmt_block_transformers="${rndtmt_block_buffer#"${rndtmt_block_text}]|"}"
                break
            elif [ "${rndtmt_expr_evaled#"]"}" != "$rndtmt_expr_evaled" ]; then
                rndtmt_block_text="$rndtmt_block_buffer"
                rndtmt_expr_evaled="${rndtmt_expr_evaled#"]"}"
                break
            else
                rndtmt_block_buffer="${rndtmt_block_buffer}]]"
            fi
        done

        rndtmt_result_transformed="$rndtmt_block_text"

        run_node_transformers \
            "rndtmt_result_transformed" \
            "$rndtmt_snapshot_num" \
            "$rndtmt_iface_num" \
            "$rndtmt_node_id" \
            "$rndtmt_block_transformers" \
            "$rndtmt_result_transformed" || rndtmt_result_transformed="$rndtmt_block_text"

        rndtmt_block_evaled="${rndtmt_block_evaled}${rndtmt_result_transformed}"
    done

    var_set "$1" "$rndtmt_block_evaled"
}

##!
##! @param $1 {identifier} - result out variable name
##!
get_snapshot_numbers_from_newest() {
    [ "${1-}" != "" ] || exit_err "get_snapshot_numbers_from_newest: empty argument 1"

    # These asserts should not fail
    [ "$g_snapshots_capacity" -gt 0 ] || 
        exit_err "get_snapshot_numbers_from_newest: unexpected 'g_snapshots_capacity' (0)"
    [ "$g_actual_snapshot" -gt 0 ] || 
        exit_err "get_snapshot_numbers_from_newest: unexpected 'g_actual_snapshot' (0)"
    [ "$g_actual_snapshot" -le "$g_snapshots_capacity" ] ||
        exit_err "get_snapshot_numbers_from_newest: 'g_actual_snapshot' must be less or equal to 'g_snapshots_capacity'"

    gspnmnw_result=""

    gspnmnw_snapshot_num="$g_actual_snapshot"

    while [ "$gspnmnw_snapshot_num" -gt 0 ]; do
        gspnmnw_result="${gspnmnw_result}${gspnmnw_result:+" "}${gspnmnw_snapshot_num}"
        gspnmnw_snapshot_num=$((gspnmnw_snapshot_num - 1))
    done

    if [ "$g_snapshots_filled" = "1" ]; then
        gspnmnw_snapshot_num="$g_snapshots_capacity"

        while [ "$gspnmnw_snapshot_num" -gt "$g_actual_snapshot" ]; do
            gspnmnw_result="${gspnmnw_result}${gspnmnw_result:+" "}${gspnmnw_snapshot_num}"
            gspnmnw_snapshot_num=$((gspnmnw_snapshot_num - 1))
        done
    fi

    var_set "$1" "$gspnmnw_result"
}

##!
##! @param $1 {identifier} - result out variable name
##! @param $2 {string} - interface name
##!
get_interface_number() {
    [ "${1-}" != "" ] || exit_err "get_interface_number: empty argument 1"
    [ "${2-}" != "" ] || exit_err "get_interface_number: empty argument 2"

    gtnfnb_num=0

    while [ "$gtnfnb_num" -lt "$g_interfaces_count" ]; do
        gtnfnb_num=$((gtnfnb_num + 1))

        gtnfnb_name=""
        var_set_expanded "gtnfnb_name" "g_interfaces${gtnfnb_num}" || return $?

        if [ "$gtnfnb_name" = "$2" ]; then
            var_set "$1" "$gtnfnb_num"
            return 0
        fi
    done

    g_interfaces_count=$((g_interfaces_count + 1))

    var_set "g_interfaces${g_interfaces_count}" "$2"

    var_set "$1" "$g_interfaces_count"
}

##!
##! @param $1 {identifier} - result out variable name
##! @param $2 {number} - interface number
##! @return ERR_INTERFACE_INVALID_NUMBER
##!
get_interface_name() {
    [ "${1-}" != "" ] || exit_err "get_interface_name: empty argument 1"
    [ "${2-}" != "" ] || exit_err "get_interface_name: empty argument 2"

    var_set_expanded "$1" "g_interfaces${2}" || return "$ERR_INTERFACE_INVALID_NUMBER"
}

#
# NODE NAMESPACE BY ID
# ==============================================================================

##!
##! @param $1 {identifier} - interface namespace
##!
init_node_namespaces_by_id() {
    [ "${1-}" != "" ] || exit_err "init_node_namespaces_by_id: empty argument 1"

    spacesep_list_init "${1}node_ns_ids" || return $?
}

##!
##! @param $1 {number} - snapshot number
##! @param $2 {number} - interface number
##! @param $3 {string} - node id
##! @param $4 {identifier} - node namespace
##!
register_node_namespace_by_id() {
    [ "${1-}" != "" ] || exit_err "register_node_namespace_by_id: empty argument 1"
    [ "${2-}" != "" ] || exit_err "register_node_namespace_by_id: empty argument 2"
    [ "${3-}" != "" ] || exit_err "register_node_namespace_by_id: empty argument 3"
    [ "${4-}" != "" ] || exit_err "register_node_namespace_by_id: empty argument 4"

    sndnsbd_iface_namespace=""
    make_interface_namespace "sndnsbd_iface_namespace" "$1" "$2" || return $?

    sndnsbd_ns_var="${sndnsbd_iface_namespace}node_ns_by_id${3}"

    [ "$g_debug" != "1" ] || log "Assigning namespace '$4' to '$sndnsbd_ns_var'"
    
    var_set "$sndnsbd_ns_var" "$4"

    [ "$g_debug" != "1" ] || log "Registering node namespace id '$3' in namespace '$sndnsbd_iface_namespace'"

    spacesep_list_unique_add "${sndnsbd_iface_namespace}node_ns_ids" "$3" || return $?
}

##!
##! @param $1 {identifier} - result out variable name
##! @param $2 {number} - snapshot number
##! @param $3 {number} - interface number
##! @param $4 {string} - node id
##! @return ERR_NODE_NS_BY_ID_NOT_EXISTS
##!
find_node_namespace_by_id() {
    [ "${1-}" != "" ] || exit_err "find_node_namespace_by_id: empty argument 1"
    [ "${2-}" != "" ] || exit_err "find_node_namespace_by_id: empty argument 2"
    [ "${3-}" != "" ] || exit_err "find_node_namespace_by_id: empty argument 3"
    [ "${4-}" != "" ] || exit_err "find_node_namespace_by_id: empty argument 4"

    gndnsbd_iface_namespace=""
    make_interface_namespace "gndnsbd_iface_namespace" "$2" "$3" || return $?

    [ "$g_debug" != "1" ] || log "Getting node namespace by id '$4' from '${gndnsbd_iface_namespace}node_ns_ids'"

    spacesep_list_has "${gndnsbd_iface_namespace}node_ns_ids" "$4" ||
        return "$ERR_NODE_NS_BY_ID_NOT_EXISTS"

    var_set_expanded "$1" "${gndnsbd_iface_namespace}node_ns_by_id${4}" ||
        return "$ERR_NODE_NS_BY_ID_NOT_EXISTS"
}

#
# INTERFACE PROPERTIES
# ==============================================================================

##!
##! @param $1 {identifier} - interface namespace
##!
init_interface_properties() {
    [ "${1-}" != "" ] || exit_err "init_interface_properties: empty argument 1"

    spacesep_list_init "${1}_properties_" || return $?
}

##!
##! @param $1 {identifier} - result out variable name
##! @param $2 {identifier} - interface namespace
##! @return ERR_SPACESEP_LIST_NOT_EXISTS
##!
get_interface_properties() {
    [ "${1-}" != "" ] || exit_err "get_interface_properties: empty argument 1"
    [ "${2-}" != "" ] || exit_err "get_interface_properties: empty argument 2"

    var_set_expanded "$1" "${2}_properties_" || return "$ERR_SPACESEP_LIST_NOT_EXISTS"
}

##!
##! @param $1 {identifier} - interface namespace
##! @param $2 {string} - property name or names
##! @return ERR_SPACESEP_LIST_NOT_EXISTS
##!
register_interface_property() {
    [ "${1-}" != "" ] || exit_err "register_interface_property: empty argument 1"
    [ "${2-}" != "" ] || exit_err "register_interface_property: empty argument 2"

    [ "$g_debug" != "1" ] || log "Registering interface property '$2' in '${1}_properties_'"

    spacesep_list_unique_add "${1}_properties_" "$2" || return $?
}

#
# NODE PROPERTIES
# ==============================================================================

##!
##! @param $1 {identifier} - node namespace
##!
init_node_properties() {
    [ "${1-}" != "" ] || exit_err "init_node_properties: empty argument 1"

    spacesep_list_init "${1}_properties_" || return $?
}

##!
##! @param $1 {identifier} - result out variable name
##! @param $2 {identifier} - node namespace
##! @return ERR_SPACESEP_LIST_NOT_EXISTS
##!
get_node_properties() {
    [ "${1-}" != "" ] || exit_err "get_node_properties: empty argument 1"
    [ "${2-}" != "" ] || exit_err "get_node_properties: empty argument 2"

    var_set_expanded "$1" "${2}_properties_" || return "$ERR_SPACESEP_LIST_NOT_EXISTS"
}

##!
##! @param $1 {identifier} - node namespace
##! @param $2 {string} - property name or names
##! @return ERR_SPACESEP_LIST_NOT_EXISTS
##!
register_node_property() {
    [ "${1-}" != "" ] || exit_err "register_node_property: empty argument 1"
    [ "${2-}" != "" ] || exit_err "register_node_property: empty argument 2"

    [ "$g_debug" != "1" ] || log "Registering node property '$2' in '${1}_properties_'"

    spacesep_list_unique_add "${1}_properties_" "$2" || return $?
}

##!
##! @param $1 {identifier} - node namespace
##! @param $2 {identifier} - property name
##! @param $3 {string} - property value
##! @return ERR_SPACESEP_LIST_NOT_EXISTS
##!
set_node_property() {
    [ "${1-}" != "" ] || exit_err "set_node_property: empty argument 1"
    [ "${2-}" != "" ] || exit_err "set_node_property: empty argument 2"
    [ "${3+a}" != "" ] || exit_err "set_node_property: argument 3 must be specified"

    [ "$g_debug" != "1" ] || log "Setting property value '$3' to variable '${1}${2}'"

    var_set "${1}${2}" "$3"

    [ "$g_debug" != "1" ] || log "Registering node property '$2' in '${1}_properties_'"

    spacesep_list_unique_add "${1}_properties_" "$2" || return $?
}

##!
##! @param $1 {identifier} - result out variable name
##! @param $2 {identifier} - node namespace
##! @param $3 {identifier} - property name
##! @return ERR_SPACESEP_LIST_NOT_EXISTS
##! @return ERR_NODE_PROPERTY_NOT_EXISTS
##!
get_node_property() {
    [ "${1-}" != "" ] || exit_err "get_node_property: empty argument 1"
    [ "${2-}" != "" ] || exit_err "get_node_property: empty argument 2"
    [ "${3-}" != "" ] || exit_err "get_node_property: empty argument 3"

    [ "$g_debug" != "1" ] || log "Checking if node property '$3' exists in '${2}_properties_'"

    spacesep_list_has "${2}_properties_" "$3" || return "$ERR_NODE_PROPERTY_NOT_EXISTS"

    [ "$g_debug" != "1" ] || log "Getting property value from variable '${2}${3}'"

    var_set_expanded "$1" "${2}${3}" || return $?
}

##!
##! @param $1 {identifier} - node namespace
##! @param $2 {identifier} - property name
##! @return ERR_SPACESEP_LIST_NOT_EXISTS
##!
has_node_property() {
    [ "${1-}" != "" ] || exit_err "has_node_property: empty argument 1"
    [ "${2-}" != "" ] || exit_err "has_node_property: empty argument 2"

    [ "$g_debug" != "1" ] || log "Checking if node property '$2' exists in '${1}_properties_'"

    spacesep_list_has "${1}_properties_" "$2"
}

##!
##! @param $1 {identifier} - node namespace
##! @param $2 {identifier} - property name
##! @return ERR_SPACESEP_LIST_NOT_EXISTS
##!
remove_node_property() {
    [ "${1-}" != "" ] || exit_err "remove_node_property: empty argument 1"
    [ "${2-}" != "" ] || exit_err "remove_node_property: empty argument 2"

    [ "$g_debug" != "1" ] || log "Unsetting node property variable '${1}${2}'"

    unset "${1}${2}" || :
    
    [ "$g_debug" != "1" ] || log "Removing node property '$2' from '${1}_properties_'"

    spacesep_list_remove "${1}_properties_" "$2"
}

#
# MAKE NAMESPACES
# ==============================================================================

##!
##! @param $1 {identifier} - result out variable name
##! @param $2 {number} - snapshot number
##!
make_snapshot_namespace() {
    [ "${1-}" != "" ] || exit_err "make_snapshot_namespace: empty argument 1"
    [ "${2-}" != "" ] || exit_err "make_snapshot_namespace: empty argument 2"

    var_set "$1" "g_snapshot${2}_"
}

##!
##! @param $1 {identifier} - result out variable name
##! @param $2 {number} - snapshot number
##! @param $3 {number} - interface number
##!
make_interface_namespace() {
    [ "${1-}" != "" ] || exit_err "make_interface_namespace: empty argument 1"
    [ "${2-}" != "" ] || exit_err "make_interface_namespace: empty argument 2"
    [ "${3-}" != "" ] || exit_err "make_interface_namespace: empty argument 3"

    var_set "$1" "g_snapshot${2}_interface${3}_"
}

##!
##! @param $1 {identifier} - result out variable name
##! @param $2 {number} - snapshot number
##! @param $3 {number} - interface number
##! @param $4 {number} - node number
##!
make_node_namespace() {
    [ "${1-}" != "" ] || exit_err "make_node_namespace: empty argument 1"
    [ "${2-}" != "" ] || exit_err "make_node_namespace: empty argument 2"
    [ "${3-}" != "" ] || exit_err "make_node_namespace: empty argument 3"
    [ "${4-}" != "" ] || exit_err "make_node_namespace: empty argument 4"

    var_set "$1" "g_snapshot${2}_interface${3}_node${4}_"
}

#
# SPACE-SEPARATED LIST
# ==============================================================================

##!
##! @param $1 {identifier} - variable that contains the list
##!
spacesep_list_init() {
    [ "${1-}" != "" ] || exit_err "spacesep_list_init: empty argument 1"

    var_set "$1" ""
}

##!
##! @param $1 {identifier} - variable that contains the list
##! @param $2 {string} - value or list of values to add
##! @return ERR_SPACESEP_LIST_NOT_EXISTS
##!
spacesep_list_unique_add() {
    [ "${1-}" != "" ] || exit_err "spacesep_list_unique_add: empty argument 1"
    [ "${2-}" != "" ] || exit_err "spacesep_list_unique_add: empty argument 2"

    splstdd_current_list=""
    var_set_expanded "splstdd_current_list" "$1" || return "$ERR_SPACESEP_LIST_NOT_EXISTS"
    
    splstdd_new_values=""

    for splstdd_val in $2; do
        [ "${splstdd_current_list#*" $splstdd_val "}" = "$splstdd_current_list" ] || continue
        splstdd_new_values="${splstdd_new_values} $splstdd_val "
    done

    if [ "$splstdd_new_values" != "" ]; then
        var_set "$1" "${splstdd_current_list}${splstdd_new_values}"
    fi
}

##!
##! @param $1 {identifier} - variable that contains the list
##! @param $2 {string} - value
##! @return ERR_SPACESEP_LIST_NOT_EXISTS
##!
spacesep_list_has() {
    [ "${1-}" != "" ] || exit_err "spacesep_list_has: empty argument 1"
    [ "${2-}" != "" ] || exit_err "spacesep_list_has: empty argument 2"

    splsths_current_list=""
    var_set_expanded "splsths_current_list" "$1" || return "$ERR_SPACESEP_LIST_NOT_EXISTS"

    [ "${splsths_current_list#*" $2 "}" != "$splsths_current_list" ]
}

##!
##! @param $1 {identifier} - variable that contains the list
##! @param $2 {string} - value or list of values to remove
##! @return ERR_SPACESEP_LIST_NOT_EXISTS
##!
spacesep_list_remove() {
    [ "${1-}" != "" ] || exit_err "spacesep_list_remove: empty argument 1"
    [ "${2-}" != "" ] || exit_err "spacesep_list_remove: empty argument 2"

    splstrm_current_list=""
    var_set_expanded "splstrm_current_list" "$1" || return "$ERR_SPACESEP_LIST_NOT_EXISTS"

    splstrm_new_list="$splstrm_current_list"

    for splstrm_val in $2; do
        while [ "$splstrm_new_list" != "" ]; do
            splstrm_head="${splstrm_new_list%%" $splstrm_val "*}"
            [ "$splstrm_head" != "$splstrm_new_list" ] || break
            splstrm_tail="${splstrm_new_list#*" $splstrm_val "}"
            [ "$splstrm_tail" != "$splstrm_new_list" ] || splstrm_tail="" # additional assert, unreachable
            splstrm_new_list="${splstrm_head}${splstrm_tail}"
        done
    done

    if [ "$splstrm_new_list" != "$splstrm_current_list" ]; then
        var_set "$1" "$splstrm_new_list"
    fi
}

#
# MISC HELPERS
# ==============================================================================

##!
##! @param $1 {identifier} - result out variable name
##! @param $2 {string} - handle
##! @return ERR_PARSE_UNEXPECTED_FORMAT
##!
canonicalize_handle() {
    [ "${1-}" != "" ] || exit_err "canonicalize_handle: empty argument 1"
    [ "${2-}" != "" ] || exit_err "canonicalize_handle: empty argument 2"

    str_contains "$2" ":" || return "$ERR_PARSE_UNEXPECTED_FORMAT"

    cnchnd_handle="$2"

    [ "${cnchnd_handle%":"}" = "$cnchnd_handle" ] || cnchnd_handle="${cnchnd_handle}0"
    [ "${cnchnd_handle#":"}" = "$cnchnd_handle" ] || cnchnd_handle="0${cnchnd_handle}"

    var_set "$1" "$cnchnd_handle"
}

##!
##! @param $1 {identifier} - result out variable prefix
##! @param $2 {string} - handle
##! @return ERR_PARSE_UNEXPECTED_FORMAT
##!
parse_handle() {
    [ "${1-}" != "" ] || exit_err "parse_handle: empty argument 1"
    [ "${2-}" != "" ] || exit_err "parse_handle: empty argument 2"

    str_contains "$2" ":" || return "$ERR_PARSE_UNEXPECTED_FORMAT"

    prshnd_handle_major="${2%:*}"
    var_set "${1}major" "$prshnd_handle_major"

    prshnd_handle_minor="${2#*:}"
    var_set "${1}minor" "$prshnd_handle_minor"
}

##!
##! @param $1 {identifier} - arguments out variable prefix
##! @param $2 {identifier} - arguments count out variable name
##! @param $3 {string} - string to parse
##! @param $4 {number} - trim argument values [optional=0]
##! @return ERR_PARSE_UNCLOSED_PARENTHESIS
##!
parse_parentheses_args() {
    [ "${1-}" != "" ] || exit_err "parse_parentheses_args: empty argument 1"
    [ "${2-}" != "" ] || exit_err "parse_parentheses_args: empty argument 2"
    [ "${3-}" != "" ] || exit_err "parse_parentheses_args: empty argument 3"

    prntrgs_string="$3"
    prntrgs_autotrim="${4-0}"

    prntrgs_args_count=0

    if [ "${prntrgs_string#*"("}" != "$prntrgs_string" ]; then
        [ "${prntrgs_string%")"}" != "$prntrgs_string" ] || return "$ERR_PARSE_UNCLOSED_PARENTHESIS"

        prntrgs_args="$prntrgs_string"
        prntrgs_args="${prntrgs_args#*"("}"
        prntrgs_args="${prntrgs_args%")"}"

        prntrgs_args_prev=""

        while [ "$prntrgs_args" != "" ] && [ "$prntrgs_args" != "$prntrgs_args_prev" ]; do
            prntrgs_args_prev="$prntrgs_args"
            prntrgs_args_count=$((prntrgs_args_count + 1))

            prntrgs_arg="${prntrgs_args%%","*}"

            if [ "$prntrgs_arg" != "$prntrgs_args" ]; then
                prntrgs_args="${prntrgs_args#*","}"
            else
                prntrgs_args=""
            fi

            if [ "$prntrgs_autotrim" = "1" ]; then
                str_trim "prntrgs_arg" "$prntrgs_arg" " " || return $?
            fi

            var_set "${1}${prntrgs_args_count}" "$prntrgs_arg"
        done
    fi

    var_set "$2" "$prntrgs_args_count"
}

##!
##! @param $1 {identifier} - result out variable name
##! @param $2 {string} - traffic amount
##! @param $3 {string} - amount unit (B, KiB, MiB, GiB, TiB) [optional=B]
##! @param $4 {number} - decimal precision [optional=1]
##! @return ERR_NUMBER_INVALID
##!
pretty_traffic1024() {
    [ "${1-}" != "" ] || exit_err "pretty_traffic1024: empty argument 1"
    [ "${2-}" != "" ] || exit_err "pretty_traffic1024: empty argument 2"

    prtfcbn_unit="${3-"B"}"
    prtfcbn_precision="${4-1}"

    [ "$prtfcbn_unit" != "B" ] || prtfcbn_units="B KiB MiB GiB TiB"
    [ "$prtfcbn_unit" != "KiB" ] || prtfcbn_units="KiB MiB GiB TiB"
    [ "$prtfcbn_unit" != "MiB" ] || prtfcbn_units="MiB GiB TiB"
    [ "$prtfcbn_unit" != "GiB" ] || prtfcbn_units="GiB TiB"
    [ "$prtfcbn_unit" != "TiB" ] || prtfcbn_units="TiB"

    pretty_div "$1" "$2" 1024 "$prtfcbn_units" "$prtfcbn_precision" || return $?
}

##!
##! @param $1 {identifier} - result out variable name
##! @param $2 {number} - initial value (int/dec)
##! @param $3 {number} - denominator (int)
##! @param $4 {string} - list of units
##! @param $5 {number} - decimal precision [optional=1]
##! @return ERR_NUMBER_NOT_INT
##! @return ERR_NUMBER_INVALID
##!
pretty_div() {
    [ "${1-}" != "" ] || exit_err "pretty_div: empty argument 1"
    [ "${2-}" != "" ] || exit_err "pretty_div: empty argument 2"
    [ "${3-}" != "" ] || exit_err "pretty_div: empty argument 3"
    [ "${4-}" != "" ] || exit_err "pretty_div: empty argument 4"

    prtdvbn_precision="${5-1}"

    [ "${3#*"."}" = "$3" ] || return "$ERR_NUMBER_NOT_INT"

    prtdvbn_result="$2"
    prtdvbn_floored="${prtdvbn_result%%"."*}"

    if [ "$prtdvbn_floored" -ge "$3" ]; then
        for prtdvbn_unit in $4; do
            [ "$prtdvbn_floored" -ge "$3" ] || break
            decimal_div "prtdvbn_result" "$prtdvbn_floored" "$3" "$prtdvbn_precision" || return $?
            prtdvbn_floored="${prtdvbn_result%%"."*}"
        done
    else
        prtdvbn_result=""
        number_floor "prtdvbn_result" "$2" "$prtdvbn_precision" || return $?

        prtdvbn_unit="${4%%" "*}"
    fi

    var_set "$1" "${prtdvbn_result} ${prtdvbn_unit}"
}

##!
##! @param $1 {identifier} - result out variable name
##! @return ERR_COMMAND_NOT_SUPPORTED
##!
time_ms() {
    [ "$g_date_supported" = "1" ] || return "$ERR_COMMAND_NOT_SUPPORTED"

    # Get nanoseconds
    tmms_time="$(date +%s%N)"

    # Strip to milliseconds
    [ "${#tmms_time}" -lt 7 ] || tmms_time="${tmms_time%??????}"

    var_set "$1" "$((tmms_time))"
}

##!
##! @return ERR_COMMAND_NOT_SUPPORTED
##!
print_time_ms() {
    prntms_value=""
    time_ms "prntms_value" || return $?
    printf "%d" "$prntms_value"
}

##!
##! @param $1 {string} - message to print
##!
log() {
    printf "%s\n" "$*"
}

##!
##! @param $1 {identifier} - result out variable name
##! @param $2 {string} - hex value
##! @return ERR_NUMBER_INVALID_HEX
##!
hex_to_int() {
    [ "${1-}" != "" ] || exit_err "hex_to_int: empty argument 1"
    [ "${2-}" != "" ] || exit_err "hex_to_int: empty argument 2"

    hxtnt_hex="$2"

    if [ "${hxtnt_hex#"0x"}" = "$hxtnt_hex" ] && [ "${hxtnt_hex#"0X"}" = "$hxtnt_hex" ]; then
        hxtnt_hex="0x${hxtnt_hex}"
    fi

    # Check if the value is a valid hex
    printf "%d" "$hxtnt_hex" >/dev/null 2>&1 || return "$ERR_NUMBER_INVALID_HEX"

    # Shell's expr converts hexs to ints
    var_set "$1" $((hxtnt_hex))
}

##!
##! Expr does not support decimals.
##!
##! @param $1 {identifier} - result out variable name
##! @param $2 {number} - multiplicand (int)
##! @param $3 {number} - multiplier (int/decimal)
##! @param $4 {number} - decimal precision [optional=3]
##! @return ERR_NUMBER_NOT_INT
##!
decimal_mul() {
    [ "${1-}" != "" ] || exit_err "decimal_mul: empty argument 1"
    [ "${2-}" != "" ] || exit_err "decimal_mul: empty argument 2"
    [ "${3-}" != "" ] || exit_err "decimal_mul: empty argument 3"

    dcmlm_multiplicand="$2"
    dcmlm_multiplier="$3"

    if [ "${2#*"."}" != "$2" ]; then
        [ "${3#*"."}" = "$3" ] || return "$ERR_NUMBER_NOT_INT"

        dcmlm_multiplicand="$3"
        dcmlm_multiplier="$2"
    fi

    dcmlm_int="${dcmlm_multiplier%%"."*}"
    dcmlm_dec="${dcmlm_multiplier#*"."}"

    [ "$dcmlm_dec" != "$dcmlm_multiplier" ] || dcmlm_dec=""

    str_trim_start "dcmlm_int" "$dcmlm_int" "0" || return $?
    [ "$dcmlm_int" != "" ] || dcmlm_int=0

    str_trim_end "dcmlm_dec" "$dcmlm_dec" "0" || return $?
    [ "$dcmlm_dec" != "" ] || dcmlm_dec=0

    dcmlm_int=$((dcmlm_int * dcmlm_multiplicand))

    # TODO: replace decimal_div with simple string replace
    if [ "$dcmlm_dec" != "0" ]; then
        dcmlm_divisor=""
        str_repeat "dcmlm_divisor" "0" "${#dcmlm_dec}" || return $?
        dcmlm_divisor="1${dcmlm_divisor}"

        dcmlm_decmul=""
        decimal_div "dcmlm_decmul" "$((dcmlm_dec * dcmlm_multiplicand))" "$dcmlm_divisor" "${4-3}" || return $?

        dcmlm_decmul_int="${dcmlm_decmul%%"."*}"
        dcmlm_decmul_dec="${dcmlm_decmul#*"."}"

        [ "$dcmlm_decmul_dec" != "$dcmlm_decmul" ] || dcmlm_decmul_dec=""

        [ "$dcmlm_decmul_int" != "" ] || dcmlm_decmul_int=0

        dcmlm_int=$((dcmlm_int + dcmlm_decmul_int))

        [ "$dcmlm_decmul_dec" != "" ] || dcmlm_decmul_dec=0
        [ "$dcmlm_decmul_dec" = "0" ] || dcmlm_int="${dcmlm_int}.${dcmlm_decmul_dec}"
    fi

    var_set "$1" "$dcmlm_int"
}

##!
##! Expr does not support decimals.
##!
##! @param $1 {identifier} - result out variable name
##! @param $2 {number} - numerator (int)
##! @param $3 {number} - denominator (int)
##! @param $4 {number} - decimal precision [optional=3]
##! @return ERR_NUMBER_NOT_INT
##!
decimal_div() {
    [ "${1-}" != "" ] || exit_err "decimal_div: empty argument 1"
    [ "${2-}" != "" ] || exit_err "decimal_div: empty argument 2"
    [ "${3-}" != "" ] || exit_err "decimal_div: empty argument 3"

    [ "${2#*"."}" = "$2" ] || return "$ERR_NUMBER_NOT_INT"
    [ "${3#*"."}" = "$3" ] || return "$ERR_NUMBER_NOT_INT"

    dcmdv_precision="${4-3}"

    dcmdv_int=$(($2 / $3))
    dcmdv_dec=$(($2 % $3))

    dcmdv_result="$dcmdv_int"

    if [ "$dcmdv_precision" != "0" ] && [ "$dcmdv_dec" != "0" ]; then
        dcmdv_digits=0

        while [ "$dcmdv_digits" -lt 100 ] && [ "$((dcmdv_dec / $3))" = "0" ]; do
            dcmdv_digits=$((dcmdv_digits + 1))
            dcmdv_dec="${dcmdv_dec}0"
        done

        if [ "$dcmdv_precision" -gt 1 ]; then
            dcmdv_zeros=""
            str_repeat "dcmdv_zeros" "0" "$((dcmdv_precision - 1))" || return $?
            dcmdv_dec="${dcmdv_dec}${dcmdv_zeros}"
        fi

        dcmdv_dec=$((dcmdv_dec / $3))
        str_trim_end "dcmdv_dec" "$dcmdv_dec" "0" || return $?

        if [ "$dcmdv_dec" != "" ]; then
            dcmdv_result="${dcmdv_result}.${dcmdv_dec}"
        fi
    fi

    var_set "$1" "$dcmdv_result"
}

##!
##! @param $1 {identifier} - integer part out variable name
##! @param $2 {identifier} - decimal part out variable name
##! @param $3 {number} - number to parse
##! @return ERR_NUMBER_INVALID
##!
number_parse() {
    [ "${1-}" != "" ] || exit_err "number_parse: empty argument 1"
    [ "${2-}" != "" ] || exit_err "number_parse: empty argument 2"
    [ "${3-}" != "" ] || exit_err "number_parse: empty argument 3"

    if [ "${3%%"."*}" != "$3" ]; then
        [ "$3" != "." ] || return "$ERR_NUMBER_INVALID"

        nbrprs_int_part="${3%%"."*}"
        [ "$nbrprs_int_part" != "" ] || nbrprs_int_part=0

        nbrprs_dec_part="${3#*"."}"
        if [ "$nbrprs_dec_part" = "$3" ] || [ "$nbrprs_dec_part" = "" ]; then
            nbrprs_dec_part=0
        else
            case "$nbrprs_dec_part" in
                *[!0-9]*)
                    return "$ERR_NUMBER_INVALID"
                    ;;
            esac
        fi
    else
        nbrprs_int_part="$3"
        nbrprs_dec_part=0
    fi

    case "$nbrprs_int_part" in
        *[!0-9]*)
            return "$ERR_NUMBER_INVALID"
            ;;
    esac

    var_set "$1" "$nbrprs_int_part"
    var_set "$2" "$nbrprs_dec_part"
}

##!
##! @param $1 {identifier} - result out variable name
##! @param $2 {number} - value (int/dec)
##! @param $3 {number} - decimal precision [optional=0]
##! @return ERR_NUMBER_INVALID
##!
number_floor() {
    [ "${1-}" != "" ] || exit_err "number_floor: empty argument 1"
    [ "${2-}" != "" ] || exit_err "number_floor: empty argument 2"

    nbrflr_precision="${3-0}"

    nbrflr_int_part=""
    nbrflr_dec_part=""
    number_parse "nbrflr_int_part" "nbrflr_dec_part" "$2" || return $?

    nbrflr_result=""

    if [ "$nbrflr_precision" = "0" ]; then
        nbrflr_result="$nbrflr_int_part"
    else
        if [ "${nbrflr_precision}" -lt "${#nbrflr_dec_part}" ]; then
            nbrflr_qs=""
            str_repeat "nbrflr_qs" "?" $((${#nbrflr_dec_part} - nbrflr_precision)) || return $?

            # Here `$nbrflr_qs` is used as a pattern intentionally and it does not need quotes
            # shellcheck disable=SC2295 # Pattern or quotes in expansion
            nbrflr_dec_part="${nbrflr_dec_part%$nbrflr_qs}"
        fi
        nbrflr_result="${nbrflr_int_part}.${nbrflr_dec_part}"
    fi

    var_set "$1" "$nbrflr_result"
}

##!
##! @param $1 {identifier} - result out variable name
##! @param $2 {number} - first number
##! @param $3 {number} - second number
##! @return ERR_NUMBER_INVALID
##!
number_compare() {
    [ "${1-}" != "" ] || exit_err "number_compare: empty argument 1"
    [ "${2-}" != "" ] || exit_err "number_compare: empty argument 2"
    [ "${3-}" != "" ] || exit_err "number_compare: empty argument 3"

    nbrcmp_number1_int_part=""
    nbrcmp_number1_dec_part=""
    number_parse "nbrcmp_number1_int_part" "nbrcmp_number1_dec_part" "$2" || return $?

    nbrcmp_number2_int_part=""
    nbrcmp_number2_dec_part=""
    number_parse "nbrcmp_number2_int_part" "nbrcmp_number2_dec_part" "$3" || return $?

    nbrcmp_result=""

    if [ "$nbrcmp_number1_int_part" -gt "$nbrcmp_number2_int_part" ]; then
        nbrcmp_result="1"
    elif [ "$nbrcmp_number1_int_part" -lt "$nbrcmp_number2_int_part" ]; then
        nbrcmp_result="-1"
    else
        if [ "$nbrcmp_number1_dec_part" -gt "$nbrcmp_number2_dec_part" ]; then
            nbrcmp_result="1"
        elif [ "$nbrcmp_number1_dec_part" -lt "$nbrcmp_number2_dec_part" ]; then
            nbrcmp_result="-1"
        else
            nbrcmp_result="0"
        fi
    fi

    var_set "$1" "$nbrcmp_result"
}

##!
##! @param $1 {identifier} - result out variable name
##! @param $2 {string} - string to unquote
##! @param $3 {identifier} - matched quote out variable name [optional=""]
##!
str_unquote() {
    [ "${1-}" != "" ] || exit_err "str_unquote: empty argument 1"
    [ "${2+a}" != "" ] || exit_err "str_unquote: argument 2 must be specified"

    stnqt_unquoted=""

    for stnqt_quote in \" \'; do
        stnqt_unquoted_left="${2#"$stnqt_quote"}"

        if [ "$stnqt_unquoted_left" != "$2" ]; then
            stnqt_unquoted="${stnqt_unquoted_left%"$stnqt_quote"}"
            [ "$stnqt_unquoted" = "$stnqt_unquoted_left" ] || break
        fi

        stnqt_quote=""
    done

    if [ "${3-}" != "" ]; then
        var_set "$3" "$stnqt_quote"
    fi

    [ "$stnqt_quote" != "" ] || stnqt_unquoted="$2"

    var_set "$1" "$stnqt_unquoted"
}

##!
##! @param $1 {string} - string
##! @param $2 {string} - substring
##!
str_contains() {
    [ "${1+a}" != "" ] || exit_err "str_contains: argument 1 must be specified"
    [ "${2+a}" != "" ] || exit_err "str_contains: argument 2 must be specified"

    [ "$2" != "" ] || return 0

    [ "$1" != "" ] || return 1
    [ "$1" != "${1#*"$2"}" ]
}

##!
##! @param $1 {identifier} - result out variable name
##! @param $2 {string} - string to repeat
##! @param $3 {number} - repeat times
##!
str_repeat() {
    [ "${1-}" != "" ] || exit_err "str_repeat: empty argument 1"
    [ "${2+a}" != "" ] || exit_err "str_repeat: argument 2 must be specified"
    [ "${3-}" != "" ] || exit_err "str_repeat: empty argument 3"

    if [ "$2" = "" ]; then
        var_set "$1" ""
        return 0
    fi

    strpt_str="$2"
    strpt_times="$3"
    strpt_result=""

    while [ "$strpt_times" -gt 0 ]; do
        if [ "$((strpt_times & 1))" -gt 0 ]; then
            strpt_result="${strpt_result}${strpt_str}"
        fi
        strpt_times=$((strpt_times >> 1))
        strpt_str="${strpt_str}${strpt_str}"
    done

    var_set "$1" "$strpt_result"
}

##!
##! @param $1 {identifier} - result out variable name
##! @param $2 {string} - side to pad (start/end)
##! @param $3 {string} - initial string
##! @param $4 {number} - target length of the resulting string
##! @param $5 {string} - string to pad with [optional=" "]
##!
str_pad() {
    [ "${1-}" != "" ] || exit_err "str_pad: empty argument 1"
    [ "${2-}" != "" ] || exit_err "str_pad: empty argument 2"
    [ "${3+a}" != "" ] || exit_err "str_pad: argument 3 must be specified"
    [ "${4-}" != "" ] || exit_err "str_pad: empty argument 4"

    strpd_result="$3"

    if [ "${#strpd_result}" -lt "$4" ]; then
        strpd_padlen=$(($4 - ${#strpd_result}))

        strpd_padstr=""
        str_repeat "strpd_padstr" "${5-" "}" "$strpd_padlen" || return $?

        if [ "${#strpd_padstr}" -gt "$strpd_padlen" ]; then
            strpd_qs=""
            str_repeat "strpd_qs" "?" $((${#strpd_padstr} - strpd_padlen)) || return $?
            # shellcheck disable=SC2295 # Expansions inside ${..} need to be quoted separately, otherwise they match as patterns
            strpd_padstr="${strpd_padstr%$strpd_qs}"
        fi

        if [ "$2" = "end" ]; then
            strpd_result="${strpd_result}${strpd_padstr}"
        else
            strpd_result="${strpd_padstr}${strpd_result}"
        fi
    fi

    var_set "$1" "$strpd_result"
}

##!
##! @param $1 {identifier} - result out variable name
##! @param $2 {string} - initial string
##! @param $3 {number} - start index
##! @param $4 {string} - end index [optional=0]
##!
str_substring() {
    [ "${1-}" != "" ] || exit_err "str_substring: empty argument 1"
    [ "${2+a}" != "" ] || exit_err "str_substring: argument 2 must be specified"
    [ "${3-}" != "" ] || exit_err "str_substring: empty argument 3"

    stsbtr_start="$3"
    stsbtr_end="${4-0}"

    stsbtr_str_len="${#2}"

    if [ "$stsbtr_start" -gt "$stsbtr_str_len" ]; then
        stsbtr_start="$stsbtr_str_len"
    fi

    if [ "$stsbtr_end" = "0" ]; then
        stsbtr_end="$stsbtr_str_len"
    elif [ "$stsbtr_end" -gt "$stsbtr_str_len" ]; then
        stsbtr_end="$stsbtr_str_len"
    fi

    stsbtr_result="$2"

    if [ "$stsbtr_start" -ge "$stsbtr_end" ]; then
        stsbtr_result=""
    else
        if [ "$stsbtr_start" -gt 0 ]; then
            stsbtr_start_replace=""
            str_repeat "stsbtr_start_replace" "?" "$stsbtr_start" || return $?

            # Here `$stsbtr_start_replace` is used as a pattern intentionally and it does not need quotes
            # shellcheck disable=SC2295 # Pattern or quotes in expansion
            stsbtr_result="${stsbtr_result#$stsbtr_start_replace}"
        fi
        if [ "$stsbtr_end" -lt "$stsbtr_str_len" ]; then
            stsbtr_end_replace=""
            str_repeat "stsbtr_end_replace" "?" "$((stsbtr_str_len - stsbtr_end))" || return $?

            # Here `$stsbtr_start_replace` is used as a pattern intentionally and it does not need quotes
            # shellcheck disable=SC2295 # Pattern or quotes in expansion
            stsbtr_result="${stsbtr_result%$stsbtr_end_replace}"
        fi
    fi

    var_set "$1" "$stsbtr_result"
}

##!
##! @param $1 {identifier} - result out variable name
##! @param $2 {string} - initial string
##! @param $3 {string} - string to trim [optional=" "]
##!
str_trim_start() {
    [ "${1-}" != "" ] || exit_err "str_trim_start: empty argument 1"
    [ "${2+a}" != "" ] || exit_err "str_trim_start: argument 2 must be specified"

    strmst_string="$2"
    strmst_trim="${3-" "}"

    while :; do
        strmst_prev="$strmst_string"
        strmst_string="${strmst_string#"$strmst_trim"}"
        [ "$strmst_string" != "$strmst_prev" ] || break
    done

    var_set "$1" "$strmst_string"
}

##!
##! @param $1 {identifier} - result out variable name
##! @param $2 {string} - initial string
##! @param $3 {string} - string to trim [optional=" "]
##!
str_trim_end() {
    [ "${1-}" != "" ] || exit_err "str_trim_end: empty argument 1"
    [ "${2+a}" != "" ] || exit_err "str_trim_end: argument 2 must be specified"

    strmnd_string="$2"
    strmnd_trim="${3-" "}"

    while :; do
        strmnd_prev="$strmnd_string"
        strmnd_string="${strmnd_string%"$strmnd_trim"}"
        [ "$strmnd_string" != "$strmnd_prev" ] || break
    done

    var_set "$1" "$strmnd_string"
}

##!
##! @param $1 {identifier} - result out variable name
##! @param $2 {string} - initial string
##! @param $3 {string} - string to trim [optional=" "]
##!
str_trim() {
    [ "${1-}" != "" ] || exit_err "str_trim: empty argument 1"
    [ "${2+a}" != "" ] || exit_err "str_trim: argument 2 must be specified"

    strrm_string="$2"
    str_trim_start "strrm_string" "$strrm_string" "${3-" "}" || return $?
    str_trim_end "$1" "$strrm_string" "${3-" "}" || return $?
}

##!
##! @param $1 {string} - function/command to check the existence of
##!
fncmd_exists() {
    [ "${1-}" != "" ] || exit_err "fncmd_exists: empty argument 1"

    command -v "$1" >/dev/null 2>&1
}

##!
##! @param $1 {identifier} - variable name to check the existence of
##!
var_exists() {
    [ "${1-}" != "" ] || exit_err "var_exists: empty argument 1"

    vrxst_isset=""
    eval "vrxst_isset=\${$1+a}"
    [ "$vrxst_isset" = "a" ]
}

##!
##! @param $1 {identifier} - result out variable name
##! @param $2 {*} - value
##!
var_set() {
    [ "${1-}" != "" ] || exit_err "var_set: empty argument 1"
    [ "${2+a}" != "" ] || exit_err "var_set: argument 2 must be specified"

    eval "$1=\"\$2\""
}

##!
##! @param $1 {identifier} - result out variable name
##! @param $2 {identifier} - identifier to expand and assign its value to variable
##! @return ERR_VAR_NOT_EXISTS
##!
var_set_expanded() {
    [ "${1-}" != "" ] || exit_err "var_set_expanded: empty argument 1"
    [ "${2-}" != "" ] || exit_err "var_set_expanded: empty argument 2"

    var_exists "$2" || return "$ERR_VAR_NOT_EXISTS"
    eval "$1=\"\$$2\""
}

##!
##! @param $1 {string} - error message
##!
exit_err() {
    xtrr_message="${1-}"

    if [ "$xtrr_message" = "" ]; then
        xtrr_message="Exit error message cannot be empty"
    fi

    printf "ERROR: %s\n" "$xtrr_message" >&2
    exit 100
}

#
# IMPORT OPTIONAL EXTENDER
# ==============================================================================

if [ -e "$(CDPATH="" cd -- "$(dirname "$0")" && pwd)"/tctree-ext ]; then
    # shellcheck disable=SC1091
    . "$(CDPATH="" cd -- "$(dirname "$0")" && pwd)"/tctree-ext
fi

#
# RUN THE APPLICATION
# ==============================================================================

if [ "${TCTREE_NORUN-}" != "1" ]; then
    main "$@" || printf "ERROR code: %d\n" "$?"
fi
